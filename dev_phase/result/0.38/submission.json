[
  {
    "id": 1,
    "response": "def max_chain_length(lst, n):\n    lst = sorted(set(lst))  # Remove duplicates and sort the list\n    chain_lengths = {x: 1 for x in lst}  # Initialize chain lengths for all numbers\n    \n    for num in lst:\n        for i in range(2, n + 1):\n            next_num = num * i\n            if next_num in lst:\n                chain_lengths[next_num] = chain_lengths[num] + 1\n    \n    return max(chain_lengths.values())"
  },
  {
    "id": 2,
    "response": "def first_repeated_char(s):\n    char_count = {}\n    for char in s:\n        if char in char_count:\n            return char\n        else:\n            char_count[char] = 1\n    return None"
  },
  {
    "id": 3,
    "response": "def get_ludic(n):\n    if n <= 2:\n        return n\n    i = n * 2\n    factors = [number for number in range(n, 1, -1) if number * 2 > n]\n    while True:\n        for a in factors:\n            if i % a != 0:\n                i += n\n                break\n            if a == factors[-1] and i % a == 0:\n                return i"
  },
  {
    "id": 4,
    "response": "def reverse_words(s):\n    # Split the string into words\n    words = s.split()\n    # Reverse the list of words\n    words.reverse()\n    # Join the reversed words back into a single string\n    reversed_string = ' '.join(words)\n    return reversed_string"
  },
  {
    "id": 5,
    "response": "def prime_num(n):\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True"
  },
  {
    "id": 6,
    "response": "def radian_degree(n):\n    return n * (math.pi / 180)"
  },
  {
    "id": 7,
    "response": "def find_literals(s, s2):\n    # Use regex to find all non-overlapping occurrences of s2 in s\n    matches = re.finditer(re.escape(s2), s)\n    # Extract the starting index of each match\n    positions = [match.start() for match in matches]\n    return positions"
  },
  {
    "id": 8,
    "response": "def bell_Number(n):\n    # Initialize a 2D list to store Bell numbers\n    bell = [[0 for i in range(n + 1)] for i in range(n + 1)]\n    \n    # The first Bell number is 1\n    bell[0][0] = 1\n    \n    # Fill the Bell triangle\n    for i in range(1, n + 1):\n        # The first element of each row is the last element of the previous row\n        bell[i][0] = bell[i - 1][i - 1]\n        \n        # Each subsequent element is the sum of the element directly above it and the element to the left of the element directly above it\n        for j in range(1, i + 1):\n            bell[i][j] = bell[i - 1][j - 1] + bell[i][j - 1]\n    \n    # The nth Bell number is the first element of the nth row\n    return bell[n][0]"
  },
  {
    "id": 9,
    "response": "def floor_Min(n, n2, n3):\n    return min(n, n2, n3)"
  },
  {
    "id": 10,
    "response": "def remove_kth_element(lst, k):\n    # Check if k is within the valid range\n    if k < 0 or k >= len(lst):\n        raise IndexError(\"k is out of bounds\")\n    \n    # Remove the k'th element\n    del lst[k]\n    \n    return lst"
  },
  {
    "id": 11,
    "response": "def max_of_nth(lst, n):\n    max_value = float('-inf')  # Initialize with the smallest possible number\n    for item in lst:\n        if len(item) > n:  # Ensure the tuple has enough elements\n            max_value = max(max_value, item[n])\n    return max_value"
  },
  {
    "id": 12,
    "response": ""
  },
  {
    "id": 13,
    "response": "def maximum_value(lst):\n    if not lst:\n        return None  # Return None if the list is empty\n    max_value = lst[0][0]  # Initialize max_value with the first element of the first tuple\n    for record in lst:\n        if record[0] > max_value:\n            max_value = record[0]\n    return max_value"
  },
  {
    "id": 14,
    "response": "def cummulative_sum(lst):\n    cumulative_sum = 0\n    result = []\n    for number in lst:\n        cumulative_sum += number\n        result.append(cumulative_sum)\n    return result"
  },
  {
    "id": 15,
    "response": "def average_tuple(tup):\n    # Flatten the tuple of tuples into a list\n    flattened_list = [num for sub_tup in tup for num in sub_tup]\n    \n    # Calculate the sum of the list\n    total_sum = sum(flattened_list)\n    \n    # Calculate the number of elements\n    num_elements = len(flattened_list)\n    \n    # Calculate the average\n    average = total_sum / num_elements\n    \n    return average"
  },
  {
    "id": 16,
    "response": "def tuple_modulo(tup, tup2):\n    # Determine the length of the shorter tuple\n    min_length = min(len(tup), len(tup2))\n    \n    # Create a new tuple with the modulo of each pair of elements\n    result = tuple(a % b for a, b in zip(tup, tup2) if b != 0)\n    \n    return result"
  },
  {
    "id": 17,
    "response": "def min_Jumps(n, n2, n3, d):\n    if d == 0:\n        return 0\n    \n    queue = deque([(0, 0, 0)])  # (x, y, jumps)\n    visited = set()\n    visited.add((0, 0))\n    \n    while queue:\n        x, y, jumps = queue.popleft()\n        \n        # Check if we have reached the target point\n        if x == d and y == 0:\n            return jumps\n        \n        # Explore all possible jumps\n        for dx, dy in [(n, 0), (n2, 0), (n3, 0), (-n, 0), (-n2, 0), (-n3, 0), (0, n), (0, n2), (0, n3), (0, -n), (0, -n2), (0, -n3)]:\n            nx, ny = x + dx, y + dy\n            \n            # Check if the new position is within bounds and not visited\n            if (nx, ny) not in visited:\n                visited.add((nx, ny))\n                queue.append((nx, ny, jumps + 1))\n    \n    return -1  # If the target point is not reachable"
  },
  {
    "id": 18,
    "response": "def div_list(lst, lst2):\n    return [a / b for a, b in zip(lst, lst2)]"
  },
  {
    "id": 19,
    "response": "def move_num(s):\n    # Separate numeric and non-numeric characters\n    numeric_chars = [char for char in s if char.isdigit()]\n    non_numeric_chars = [char for char in s if not char.isdigit()]\n    \n    # Concatenate numeric and non-numeric characters\n    result = ''.join(numeric_chars + non_numeric_chars)\n    \n    return result"
  },
  {
    "id": 20,
    "response": "def largest_subset(lst, n):\n    from collections import Counter\n    \n    # Count the remainders when elements are divided by n\n    remainder_count = Counter(x % n for x in lst)\n    \n    # Initialize the size of the largest subset\n    largest_subset_size = 0\n    \n    # Handle the remainder 0 separately\n    if 0 in remainder_count:\n        largest_subset_size += remainder_count[0]\n    \n    # Handle other remainders\n    for r in range(1, n // 2 + 1):\n        if r in remainder_count and (n - r) in remainder_count:\n            largest_subset_size += min(remainder_count[r], remainder_count[n - r])\n    \n    # If n is even, handle the remainder n/2\n    if n % 2 == 0 and n // 2 in remainder_count:\n        largest_subset_size += 1\n    \n    return largest_subset_size"
  },
  {
    "id": 21,
    "response": "def increment_numerics(lst, n):\n    result = []\n    for item in lst:\n        new_item = ''\n        i = 0\n        while i < len(item):\n            if item[i].isdigit():\n                start = i\n                while i < len(item) and item[i].isdigit():\n                    i += 1\n                num = int(item[start:i])\n                new_item += str(num + n)\n            else:\n                new_item += item[i]\n                i += 1\n        result.append(new_item)\n    return result"
  },
  {
    "id": 22,
    "response": "def get_median(lst, lst2, n):\n    merged = sorted(lst + lst2)\n    length = len(merged)\n    if length % 2 == 1:\n        return merged[length // 2]\n    else:\n        return (merged[length // 2 - 1] + merged[length // 2]) / 2"
  },
  {
    "id": 23,
    "response": "def nth_nums(lst, n):\n    return [lambda x: x**n for x in lst]"
  },
  {
    "id": 24,
    "response": "def is_upper(s):\n    return s.upper()"
  },
  {
    "id": 25,
    "response": "def swap_List(lst):\n    # Check if the list has at least two elements\n    if len(lst) < 2:\n        return lst\n    \n    # Swap the first and last elements\n    lst[0], lst[-1] = lst[-1], lst[0]\n    \n    return lst"
  },
  {
    "id": 26,
    "response": "def triangle_area(n):\n    return n ** 2"
  },
  {
    "id": 27,
    "response": "def find_first_missing(lst, n, n2):\n    # Convert the list to a set for O(1) average-time complexity lookups\n    num_set = set(lst)\n    \n    # Iterate through the natural numbers starting from 1\n    for i in range(1, n2 + 1):\n        if i not in num_set:\n            return i"
  },
  {
    "id": 28,
    "response": "def replace_spaces(s):\n    result = []\n    for char in s:\n        if char == ' ':\n            result.append('%20')\n        else:\n            result.append(char)\n    return ''.join(result)"
  },
  {
    "id": 29,
    "response": "def Split(lst):\n    numbers = []\n    for item in lst:\n        if isinstance(item, (int, float)):\n            numbers.append(item)\n    return numbers"
  },
  {
    "id": 30,
    "response": "def get_coordinates(tup):\n    coordinates = []\n    for item in tup:\n        if isinstance(item, tuple):\n            coordinates.append(item)\n    return coordinates"
  },
  {
    "id": 31,
    "response": "def replace_spaces(s):\n    # Replace spaces with underscores\n    s = re.sub(r' ', '_', s)\n    # Replace underscores with spaces\n    s = re.sub(r'_', ' ', s)\n    return s"
  },
  {
    "id": 32,
    "response": "def move_zero(lst):\n    # Filter out non-zero elements and store them in a new list\n    non_zeros = [x for x in lst if x != 0]\n    # Count the number of zeros in the original list\n    zero_count = lst.count(0)\n    # Create a list of zeros with the same count as the number of zeros in the original list\n    zeros = [0] * zero_count\n    # Concatenate the non-zero elements with the list of zeros\n    result = non_zeros + zeros\n    return result"
  },
  {
    "id": 33,
    "response": "def pair_OR_Sum(lst, n):\n    total_sum = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            total_sum += lst[i] ^ lst[j]\n    return total_sum"
  },
  {
    "id": 34,
    "response": "def even_Power_Sum(n):\n    total_sum = 0\n    for i in range(1, n + 1):\n        even_number = 2 * i\n        total_sum += even_number ** 4\n    return total_sum"
  },
  {
    "id": 35,
    "response": "def heap_sort(lst):\n    # Convert the list into a max heap by inserting negative values\n    max_heap = [-x for x in lst]\n    heapq.heapify(max_heap)\n    \n    # Extract the elements from the heap and place them in the list in sorted order\n    sorted_lst = [-heapq.heappop(max_heap) for _ in range(len(max_heap))]\n    \n    return sorted_lst"
  },
  {
    "id": 36,
    "response": ""
  },
  {
    "id": 37,
    "response": ""
  },
  {
    "id": 38,
    "response": "def wind_chill(n, n2):\n    wind_chill_index = 13.12 + 0.6215 * n - 11.37 * (n2 ** 0.16) + 0.3965 * n * (n2 ** 0.16)\n    return wind_chill_index"
  },
  {
    "id": 39,
    "response": "def sample_nam(lst):\n    # Filter names that start with a small letter\n    filtered_names = [name for name in lst if name[0].islower()]\n    \n    # Calculate the sum of the lengths of the filtered names\n    total_length = sum(len(name) for name in filtered_names)\n    \n    return total_length"
  },
  {
    "id": 40,
    "response": "def remove_parenthesis(s):\n    stack = []\n    result = []\n    for char in s:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if stack:\n                stack.pop()\n            else:\n                result.append(char)\n        else:\n            if not stack:\n                result.append(char)\n    return ''.join(result)"
  },
  {
    "id": 41,
    "response": "def is_nonagonal(N):\n    a = 7\n    b = -5\n    c = -2 * N\n    \n    discriminant = b**2 - 4 * a * c\n    \n    if discriminant < 0:\n        return False\n    \n    sqrt_discriminant = discriminant**0.5\n    \n    n1 = (-b + sqrt_discriminant) / (2 * a)\n    n2 = (-b - sqrt_discriminant) / (2 * a)\n    \n    if n1 > 0 and n1.is_integer():\n        return True\n    if n2 > 0 and n2.is_integer():\n        return True\n    \n    return False"
  },
  {
    "id": 42,
    "response": "def remove_similar_row(lst):\n    seen = set()\n    result = []\n    for row in lst:\n        # Convert the row to a tuple so it can be added to a set\n        row_tuple = tuple(row)\n        if row_tuple not in seen:\n            seen.add(row_tuple)\n            result.append(row)\n    return result"
  },
  {
    "id": 43,
    "response": "def text_match_wordz_middle(s):\n    # Check if the word starts or ends with 'z'\n    if s.startswith('z') or s.endswith('z'):\n        return True\n    else:\n        return False"
  },
  {
    "id": 44,
    "response": "def reverse_array_upto_k(lst, k):\n    # Ensure k is within the bounds of the array\n    if k >= len(lst):\n        k = len(lst) - 1\n    \n    # Initialize pointers for the start and end of the array\n    start = 0\n    end = k\n    \n    # Swap elements until the pointers meet in the middle\n    while start < end:\n        # Swap the elements at start and end indices\n        lst[start], lst[end] = lst[end], lst[start]\n        \n        # Move the pointers towards the middle\n        start += 1\n        end -= 1\n    \n    return lst"
  },
  {
    "id": 45,
    "response": "def find_k_product(lst, k):\n    # Check if the list is empty or if any tuple has less than k elements\n    if not lst or any(len(tup) < k for tup in lst):\n        raise ValueError(\"List is empty or some tuples have less than k elements\")\n    \n    # Extract the kth element from each tuple and calculate the product\n    kth_elements = [tup[k-1] for tup in lst]\n    product = reduce(mul, kth_elements, 1)\n    \n    return product"
  },
  {
    "id": 46,
    "response": "def No_of_cubes(n, k):\n    if n % k != 0:\n        return 0\n    return (n // k) ** 3"
  },
  {
    "id": 47,
    "response": "def split_upperstring(s):\n    result = []\n    for char in s:\n        if char.isupper():\n            result.append(' ' + char)\n        else:\n            result.append(char)\n    return ''.join(result)"
  },
  {
    "id": 48,
    "response": "def exchange_elements(lst):\n    # Iterate through the list in steps of 2\n    for i in range(0, len(lst) - 1, 2):\n        # Swap the elements at positions i and i+1\n        lst[i], lst[i + 1] = lst[i + 1], lst[i]\n    return lst"
  },
  {
    "id": 49,
    "response": "def sum_Range_list(lst, n, n2):\n    # Check if n2 is greater than the length of the list\n    if n2 > len(lst):\n        n2 = len(lst)\n    \n    # Calculate the sum of the elements in the specified range\n    total_sum = sum(lst[n:n2+1])\n    \n    return total_sum"
  },
  {
    "id": 50,
    "response": "def are_Equal(lst, lst2, n, n2):\n    if n != n2:\n        return False\n    for i in range(n):\n        if lst[i] != lst2[i]:\n            return False\n    return True"
  },
  {
    "id": 51,
    "response": "def check_subset(tup, tup2):\n    set1 = set(tup)\n    set2 = set(tup2)\n    return set1.issubset(set2)"
  },
  {
    "id": 52,
    "response": "def matrix_to_list(lst):\n    # Initialize an empty list to store the flattened elements\n    flat_list = []\n    \n    # Iterate through each column in the 3D matrix\n    for column in lst:\n        # Collect all elements from the current column\n        for row in column:\n            for element in row:\n                flat_list.append(element)\n    \n    return flat_list"
  },
  {
    "id": 53,
    "response": "def grouping_dictionary(lst):\n    grouped_dict = defaultdict(list)\n    for key, value in lst:\n        grouped_dict[key].append(value)\n    return dict(grouped_dict)"
  },
  {
    "id": 54,
    "response": "def rectangle_perimeter(n, n2):\n    return 2 * (n + n2)"
  },
  {
    "id": 55,
    "response": "def fifth_Power_Sum(n):\n    total_sum = 0\n    for i in range(1, n + 1):\n        total_sum += i ** 5\n    return total_sum"
  },
  {
    "id": 56,
    "response": "def find_Min_Sum(lst, lst2, n):\n    # Sort both lists\n    lst.sort()\n    lst2.sort()\n    \n    # Calculate the sum of absolute differences\n    min_sum = sum(abs(a - b) for a, b in zip(lst, lst2))\n    \n    return min_sum"
  },
  {
    "id": 57,
    "response": "def first_digit(n):\n    import math\n    factorial = math.factorial(n)\n    first_digit_str = str(factorial)[0]\n    return int(first_digit_str)"
  },
  {
    "id": 58,
    "response": "def max_occurrences(lst):\n    if not lst:\n        return None\n    \n    count_dict = {}\n    for item in lst:\n        if item in count_dict:\n            count_dict[item] += 1\n        else:\n            count_dict[item] = 1\n    \n    max_count = 0\n    max_item = None\n    for item, count in count_dict.items():\n        if count > max_count:\n            max_count = count\n            max_item = item\n    \n    return max_item"
  },
  {
    "id": 59,
    "response": "def remove_duplicates(lst):\n    return list(set(lst))"
  },
  {
    "id": 60,
    "response": "def find_Points(n, n2, n3, n4):\n    # Check if n is not within the range (n3, n4)\n    if n <= n3 or n >= n4:\n        return n\n    # Check if n2 is not within the range (n3, n4)\n    elif n2 <= n3 or n2 >= n4:\n        return n2\n    # If neither n nor n2 is within the range, return n3 (or n4, as they are the boundaries)\n    else:\n        return n3"
  },
  {
    "id": 61,
    "response": "def max_sum_of_three_consecutive(lst, n):\n    max_sum = float('-inf')\n    \n    for i in range(n - 2):\n        for j in range(i + 2, n):\n            if abs(i - j) > 1:\n                current_sum = lst[i] + lst[i + 1] + lst[j]\n                max_sum = max(max_sum, current_sum)\n    \n    return max_sum"
  },
  {
    "id": 62,
    "response": "def sorted_dict(dct):\n    # Find the key with the maximum length of its associated list\n    max_key = max(dct, key=lambda k: len(dct[k]))\n    # Return the list associated with the key with the maximum length\n    return dct[max_key]"
  },
  {
    "id": 63,
    "response": "def find_max_val(n, n2, n3):\n    # Assuming we are looking for the largest possible k within a certain range\n    # For simplicity, let's assume the range is from 0 to a large number\n    # We can adjust the range as needed\n    max_k = 0\n    for k in range(n, n2 * n3 + 1):\n        if k % n2 == n3:\n            max_k = k\n    return max_k"
  },
  {
    "id": 64,
    "response": "def average_even(n):\n    if n < 2:\n        return 0  # No even numbers if n is less than 2\n    even_numbers = [i for i in range(2, n + 1, 2)]\n    total_sum = sum(even_numbers)\n    count = len(even_numbers)\n    average = total_sum / count\n    return average"
  },
  {
    "id": 65,
    "response": "def move_last(lst):\n    if len(lst) <= 1:\n        return lst\n    else:\n        first_element = lst.pop(0)\n        lst.append(first_element)\n        return lst"
  },
  {
    "id": 66,
    "response": "def count_char(s):\n    char_count = {}\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    return char_count"
  },
  {
    "id": 67,
    "response": "def Check_Vow(s, s2):\n    vowels = set('aeiouAEIOU')\n    count_s = 0\n    count_s2 = 0\n    \n    for char in s:\n        if char in vowels:\n            count_s += 1\n    \n    for char in s2:\n        if char in vowels:\n            count_s2 += 1\n    \n    return count_s, count_s2"
  },
  {
    "id": 68,
    "response": "def replace(s, s2):\n    result = \"\"\n    for char in s:\n        if char in s2:\n            result += s2[s2.index(char)]\n        else:\n            result += char\n    return result"
  },
  {
    "id": 69,
    "response": "def check_IP(s):\n    # Regex pattern for a valid IP address\n    pattern = r'^(\\d{1,3}\\.){3}\\d{1,3}$'\n    \n    # Check if the string matches the pattern\n    if not re.match(pattern, s):\n        return False\n    \n    # Split the string into parts\n    parts = s.split('.')\n    \n    # Check each part to ensure it is between 0 and 255 and has no leading zeros\n    for part in parts:\n        if not 0 <= int(part) <= 255 or (len(part) > 1 and part.startswith('0')):\n            return False\n    \n    return True"
  },
  {
    "id": 70,
    "response": ""
  },
  {
    "id": 71,
    "response": "def set_right_most_unset_bit(n):\n    if n == 0:\n        return 1\n    if n & (n + 1) == 0:\n        return n\n    return n | (n & (n + 1))"
  },
  {
    "id": 72,
    "response": "def max_of_three(n, n2, n3):\n    return max(n, n2, n3)"
  },
  {
    "id": 73,
    "response": "def convert(lst):\n    # Convert each integer in the list to a string\n    str_lst = [str(num) for num in lst]\n    # Join all string representations together\n    combined_str = ''.join(str_lst)\n    # Convert the combined string back to an integer\n    result = int(combined_str)\n    return result"
  },
  {
    "id": 74,
    "response": "def remove_duplicate(s):\n    words = s.split()\n    unique_words = set(words)\n    result = ' '.join(unique_words)\n    return result"
  },
  {
    "id": 75,
    "response": "def sum_nums(n, n2, n3, n4):\n    total_sum = n + n2 + n3 + n4\n    if 10 <= total_sum <= 30:\n        return 20\n    else:\n        return total_sum"
  },
  {
    "id": 76,
    "response": "def remove_extra_char(s):\n    # Use regular expression to replace non-alphanumeric characters with an empty string\n    cleaned_string = re.sub(r'[^a-zA-Z0-9]', '', s)\n    return cleaned_string"
  },
  {
    "id": 77,
    "response": "def validity_triangle(n, n2, n3):\n    # Check the triangle inequality theorem\n    if (n + n2 > n3) and (n + n3 > n2) and (n2 + n3 > n):\n        return True\n    else:\n        return False"
  },
  {
    "id": 78,
    "response": ""
  },
  {
    "id": 79,
    "response": "def access_key(dct, n):\n    # Extract keys from the dictionary\n    keys = list(dct.keys())\n    \n    # Sort the keys\n    sorted_keys = sorted(keys)\n    \n    # Access the nth element based on the sorted keys\n    if n - 1 < len(sorted_keys):\n        return dct[sorted_keys[n - 1]]\n    else:\n        return None  # Return None if n is out of bounds"
  },
  {
    "id": 80,
    "response": "def increasing_trend(lst):\n    for i in range(1, len(lst)):\n        if lst[i] < lst[i - 1]:\n            return False\n    return True"
  },
  {
    "id": 81,
    "response": "def smallest_divisor(n):\n    if n <= 1:\n        return None  # No divisors for numbers less than or equal to 1\n    for i in range(2, n + 1):\n        if n % i == 0:\n            return i"
  },
  {
    "id": 82,
    "response": "def mul_list(lst, lst2):\n    return list(map(lambda x, y: x * y, lst, lst2))"
  },
  {
    "id": 83,
    "response": "def sum_of_squares(n):\n    for a in range(int(math.sqrt(n)) + 1):\n        b_squared = n - a**2\n        b = int(math.sqrt(b_squared))\n        if b * b == b_squared:\n            return True\n    return False"
  },
  {
    "id": 84,
    "response": "def count_Char(s, s2):\n    char_count = {}\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    return char_count"
  },
  {
    "id": 85,
    "response": "def is_prime(num):\n    if num <= 1:\n        return False\n    for i in range(2, int(num**0.5) + 1):\n        if num % i == 0:\n            return False\n    return True"
  },
  {
    "id": 86,
    "response": "def freq_element(tup):\n    freq_dict = {}\n    for element in tup:\n        if element in freq_dict:\n            freq_dict[element] += 1\n        else:\n            freq_dict[element] = 1\n    return freq_dict"
  },
  {
    "id": 87,
    "response": "def recur_gcd(n, n2):\n    if n2 == 0:\n        return n\n    else:\n        return recur_gcd(n2, n % n2)"
  },
  {
    "id": 88,
    "response": "def len_complex(n, n2):\n    return math.sqrt(n**2 + n2**2)"
  },
  {
    "id": 89,
    "response": "def min_jumps(lst, n):\n    if n <= 1:\n        return 0\n    if lst[0] == 0:\n        return -1\n    \n    dp = [float('inf')] * n\n    dp[0] = 0\n    \n    for i in range(1, n):\n        for j in range(i):\n            if i <= j + lst[j] and dp[j] != float('inf'):\n                dp[i] = min(dp[i], dp[j] + 1)\n                break\n    \n    return dp[n-1] if dp[n-1] != float('inf') else -1"
  },
  {
    "id": 90,
    "response": "def mul_consecutive_nums(lst):\n    if len(lst) < 2:\n        return []\n    \n    result = []\n    for i in range(len(lst) - 1):\n        result.append(lst[i] * lst[i + 1])\n    \n    return result"
  },
  {
    "id": 91,
    "response": "def group_element(lst):\n    grouped_dict = {}\n    for item in lst:\n        key = item[1]\n        if key not in grouped_dict:\n            grouped_dict[key] = [item[0]]\n        else:\n            grouped_dict[key].append(item[0])\n    return grouped_dict"
  },
  {
    "id": 92,
    "response": "def last_two_digits(n):\n    if n == 0 or n == 1:\n        return 1\n    factorial = 1\n    for i in range(2, n + 1):\n        factorial = (factorial * i) % 100\n    return factorial"
  },
  {
    "id": 93,
    "response": "def remove_multiple_spaces(s):\n    return re.sub(r'\\s+', ' ', s)"
  },
  {
    "id": 94,
    "response": "def extract_unique(dct):\n    value_counts = {}\n    for value in dct.values():\n        if value in value_counts:\n            value_counts[value] += 1\n        else:\n            value_counts[value] = 1\n    \n    unique_values = [value for value, count in value_counts.items() if count == 1]\n    return unique_values"
  },
  {
    "id": 95,
    "response": "def check_greater(tup, tup2):\n    if len(tup) != len(tup2):\n        raise ValueError(\"Both tuples must have the same length\")\n    \n    for i in range(len(tup)):\n        if tup2[i] <= tup[i]:\n            return False\n    return True"
  },
  {
    "id": 96,
    "response": "def zip_list(lst, lst2):\n    return list(zip(lst, lst2))"
  },
  {
    "id": 97,
    "response": "def count_even(lst):\n    even_count = len(list(filter(lambda x: x % 2 == 0, lst)))\n    return even_count"
  },
  {
    "id": 98,
    "response": "def sort_dict_item(dct):\n    # Sort the dictionary items based on their values in descending order\n    sorted_items = sorted(dct.items(), key=lambda item: item[1], reverse=True)\n    # Create a new dictionary from the sorted items\n    sorted_dict = dict(sorted_items)\n    return sorted_dict"
  },
  {
    "id": 99,
    "response": "def min_Swaps(s, s2):\n    # Check if the lengths of the strings are the same\n    if len(s) != len(s2):\n        return -1\n    \n    # Count the number of '0's and '1's in both strings\n    count_s = {'0': s.count('0'), '1': s.count('1')}\n    count_s2 = {'0': s2.count('0'), '1': s2.count('1')}\n    \n    # If the counts of '0's and '1's do not match, return -1\n    if count_s != count_s2:\n        return -1\n    \n    # Calculate the number of swaps needed\n    swaps = 0\n    i = 0\n    while i < len(s):\n        if s[i] != s2[i]:\n            j = i + 1\n            while j < len(s) and s[j] != s[i]:\n                j += 1\n            if j == len(s):\n                return -1\n            # Swap the characters\n            s = s[:i] + s[j] + s[i+1:j] + s[i] + s[j+1:]\n            swaps += 1\n        i += 1\n    \n    return swaps"
  },
  {
    "id": 100,
    "response": "def count_range_in_list(lst, n, n2):\n    count = 0\n    for num in lst:\n        if n <= num <= n2:\n            count += 1\n    return count"
  },
  {
    "id": 101,
    "response": "def equilibrium_index(lst):\n    for i in range(len(lst)):\n        left_sum = sum(lst[:i])\n        right_sum = sum(lst[i+1:])\n        if left_sum == right_sum:\n            return i\n    return -1"
  },
  {
    "id": 102,
    "response": "def smallest_multiple(n, n2):\n    if n <= 2:\n        return n\n    i = n * 2\n    factors = [number for number in range(n, 1, -1) if number * 2 > n]\n    while True:\n        for a in factors:\n            if i % a != 0:\n                i += n\n                break\n            if a == factors[-1] and i % a == 0:\n                return i"
  },
  {
    "id": 103,
    "response": ""
  },
  {
    "id": 104,
    "response": "def harmonic_sum(n):\n    if n <= 0:\n        return 0\n    total = 0\n    for i in range(1, n):\n        total += 1 / i\n    return total"
  },
  {
    "id": 105,
    "response": "def sort_sublists(lst):\n    return sorted(lst, key=lambda x: (len(x), x))"
  },
  {
    "id": 106,
    "response": "def is_subset(lst, n, lst2, n2):\n    # Create a set from the second list for faster lookup\n    set2 = set(lst2)\n    \n    # Iterate through each element in the first list\n    for i in range(n):\n        # Check if the current element is in the set of the second list\n        if lst[i] not in set2:\n            return False\n    \n    # If all elements are found, return True\n    return True"
  },
  {
    "id": 107,
    "response": "def count_Set_Bits(n):\n    total_bits = 0\n    for i in range(1, n + 1):\n        total_bits += bin(i).count('1')\n    return total_bits"
  },
  {
    "id": 108,
    "response": "def convert(s):\n    return list(s)"
  },
  {
    "id": 109,
    "response": "def get_unique(lst):\n    unique_elements = set()\n    for tup in lst:\n        for element in tup:\n            unique_elements.add(element)\n    return list(unique_elements)"
  },
  {
    "id": 110,
    "response": ""
  },
  {
    "id": 111,
    "response": "def product_Equal(n):\n    product = 1\n    for digit in str(n):\n        product *= int(digit)\n    return product == n"
  },
  {
    "id": 112,
    "response": "def remove_duplicate(lst):\n    return list(set(lst))"
  },
  {
    "id": 113,
    "response": "def check_valid(tup):\n    for value in tup:\n        if not isinstance(value, str) or value == \"\":\n            return False\n    return True"
  },
  {
    "id": 114,
    "response": "def count_Fac(n):\n    def prime_factors(n):\n        i = 2\n        factors = {}\n        while i * i <= n:\n            if n % i:\n                i += 1\n            else:\n                n //= i\n                if i in factors:\n                    factors[i] += 1\n                else:\n                    factors[i] = 1\n        if n > 1:\n            factors[n] = 1\n        return factors"
  },
  {
    "id": 115,
    "response": "def str_to_tuple(s):\n    # Split the string by spaces to get individual number strings\n    number_strings = s.split()\n    \n    # Convert each number string to an integer\n    numbers = [int(num) for num in number_strings]\n    \n    # Create a tuple from the list of integers\n    result_tuple = tuple(numbers)\n    \n    return result_tuple"
  },
  {
    "id": 116,
    "response": "def rombus_perimeter(n):\n    return 4 * n"
  },
  {
    "id": 117,
    "response": "def sd_calc(lst):\n    n = len(lst)\n    mean = sum(lst) / n\n    variance = sum((x - mean) ** 2 for x in lst) / n\n    return math.sqrt(variance)"
  },
  {
    "id": 118,
    "response": "def alternate_elements(lst):\n    return [lst[i] for i in range(0, len(lst), 2)]"
  },
  {
    "id": 119,
    "response": "def text_match(s):\n    pattern = 'ab|a0'\n    if re.search(pattern, s):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'"
  },
  {
    "id": 120,
    "response": "def add_dict_to_tuple(tup, dct):\n    result = []\n    for item in tup:\n        if item in dct:\n            result.append(item + dct[item])\n        else:\n            result.append(item)\n    return tuple(result)"
  },
  {
    "id": 121,
    "response": "def maxAverageOfPath(matrix, n):\n    # Initialize a DP table with the same dimensions as the matrix\n    dp = [[0] * n for _ in range(n)]\n    \n    # Fill the DP table\n    for i in range(n):\n        for j in range(n):\n            if i == 0 and j == 0:\n                dp[i][j] = matrix[i][j]\n            elif i == 0:\n                dp[i][j] = dp[i][j-1] + matrix[i][j]\n            elif j == 0:\n                dp[i][j] = dp[i-1][j] + matrix[i][j]\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + matrix[i][j]\n    \n    # The maximum average path value is the value in the bottom-right corner of the DP table\n    max_value = dp[n-1][n-1]\n    \n    # Calculate the average\n    max_average = max_value / (2 * n - 1)\n    \n    return max_average"
  },
  {
    "id": 122,
    "response": "def filter_data(dct, n, n2):\n    filtered_dict = {}\n    for key, value in dct.items():\n        if n <= value['height'] <= n2 and n <= value['width'] <= n2:\n            filtered_dict[key] = value\n    return filtered_dict"
  },
  {
    "id": 123,
    "response": "def count_same_pair(lst, lst2):\n    count = 0\n    for i in range(min(len(lst), len(lst2))):\n        if lst[i] == lst2[i]:\n            count += 1\n    return count"
  },
  {
    "id": 124,
    "response": "def power_base_sum(n, n2):\n    # Convert the number to a string to iterate over each digit\n    digits = str(n)\n    \n    # Sum the digits\n    digit_sum = sum(int(digit) for digit in digits)\n    \n    # Raise the sum to the power of n2\n    result = digit_sum ** n2\n    \n    return result"
  },
  {
    "id": 125,
    "response": "def extract_quotation(s):\n    pattern = r'\"(.*?)\"'\n    matches = re.findall(pattern, s)\n    return matches"
  },
  {
    "id": 126,
    "response": "def multiply_elements(tup):\n    product = 1\n    for element in tup:\n        product *= element\n    return product"
  },
  {
    "id": 127,
    "response": "def remove_char(s):\n    return re.sub(r'[a-zA-Z0-9]', '', s)"
  },
  {
    "id": 128,
    "response": "def sum_list(lst, lst2):\n    if len(lst) != len(lst2):\n        raise ValueError(\"Both lists must have the same length\")\n    result = []\n    for i in range(len(lst)):\n        result.append(lst[i] + lst2[i])\n    return result"
  },
  {
    "id": 129,
    "response": "def add_list(lst, lst2):\n    # Use map with a lambda function to add corresponding elements of the two lists\n    result = map(lambda x, y: x + y, lst, lst2)\n    # Convert the map object to a list and return it\n    return list(result)"
  },
  {
    "id": 130,
    "response": "def consecutive_duplicates(lst):\n    if not lst:\n        return []\n    \n    result = [lst[0]]\n    for i in range(1, len(lst)):\n        if lst[i] != lst[i - 1]:\n            result.append(lst[i])\n    \n    return result"
  },
  {
    "id": 131,
    "response": "def lateralsurface_cone(n, n2):\n    r = n\n    h = n2\n    l = math.sqrt(r**2 + h**2)\n    lateral_surface_area = math.pi * r * l\n    return lateral_surface_area"
  },
  {
    "id": 132,
    "response": "def replace_specialchar(s):\n    special_chars = [' ', ',', '.']\n    replacement_char = '_'\n    for char in special_chars:\n        s = s.replace(char, replacement_char)\n    return s"
  },
  {
    "id": 133,
    "response": "def find_first_occurrence(lst, n):\n    for i in range(len(lst)):\n        if lst[i] == n:\n            return i\n    return -1"
  },
  {
    "id": 134,
    "response": "def sum_Of_Subarray_Prod(lst, n):\n    total_sum = 0\n    \n    # Iterate through all possible start indices\n    for i in range(n):\n        product = 1\n        \n        # Iterate through all possible end indices\n        for j in range(i, n):\n            product *= lst[j]\n            total_sum += product\n    \n    return total_sum"
  },
  {
    "id": 135,
    "response": "def toggle_middle_bits(n):\n    if n <= 2:\n        return n  # No middle bits to toggle for numbers 1 and 2\n    \n    # Get the number of bits in n\n    num_bits = n.bit_length()\n    \n    # Create a mask with all bits set to 1 except the first and last bits\n    mask = (1 << (num_bits - 1)) - 1  # This will have all bits set to 1 up to the second last bit\n    \n    # Toggle the bits in n that are not the first and last bits\n    result = n ^ mask\n    \n    return result"
  },
  {
    "id": 136,
    "response": "def left_insertion(lst, n):\n    lst.insert(0, n)\n    return lst"
  },
  {
    "id": 137,
    "response": "def check_str(s):\n    vowels = \"aeiouAEIOU\"\n    if s and s[0] in vowels:\n        return True\n    return False"
  },
  {
    "id": 138,
    "response": "def geometric_sum(n):\n    if n <= 0:\n        return 0\n    return 1 + geometric_sum(n - 1)"
  },
  {
    "id": 139,
    "response": "def find_Index(n):\n    def count_divisors(num):\n        count = 0\n        for i in range(1, int(num**0.5) + 1):\n            if num % i == 0:\n                count += 1\n                if i != num // i:\n                    count += 1\n        return count"
  },
  {
    "id": 140,
    "response": "def tuple_to_dict(tup):\n    result_dict = {}\n    for item in tup:\n        if len(item) == 2:\n            key, value = item\n            result_dict[key] = value\n    return result_dict"
  },
  {
    "id": 141,
    "response": "def all_Characters_Same(s):\n    return len(set(s)) == 1"
  },
  {
    "id": 142,
    "response": "def area_tetrahedron(n):\n    return (3 ** 0.5) * n ** 2"
  },
  {
    "id": 143,
    "response": "def rotate_right(lst, n, n2):\n    # Extract the sublist to be rotated\n    sublist = lst[:n2]\n    \n    # Rotate the sublist to the right by n positions\n    rotated_sublist = sublist[-n:] + sublist[:-n]\n    \n    # Replace the first n2 elements of the original list with the rotated sublist\n    lst[:n2] = rotated_sublist\n    \n    return lst"
  },
  {
    "id": 144,
    "response": "def check_none(tup):\n    for element in tup:\n        if element is None:\n            return True\n    return False"
  },
  {
    "id": 145,
    "response": "def divisible_by_digits(n, n2):\n    # Convert the number to a string to access each digit\n    str_n = str(n)\n    \n    # Iterate through each digit\n    for digit in str_n:\n        # Convert the digit back to an integer\n        digit = int(digit)\n        \n        # Check if the number is divisible by the digit\n        if digit == 0 or n % digit != 0:\n            return False\n    \n    return True"
  },
  {
    "id": 146,
    "response": "def sector_area(n, n2):\n    return (n2 / 360) * math.pi * n**2"
  },
  {
    "id": 147,
    "response": "def lcs_of_three(s, s2, s3, n, n2, n3):\n    # Create a 3D DP table initialized to 0\n    dp = [[[0 for _ in range(n3 + 1)] for _ in range(n2 + 1)] for _ in range(n + 1)]\n    \n    # Fill the DP table\n    for i in range(1, n + 1):\n        for j in range(1, n2 + 1):\n            for k in range(1, n3 + 1):\n                if s[i - 1] == s2[j - 1] == s3[k - 1]:\n                    dp[i][j][k] = dp[i - 1][j - 1][k - 1] + 1\n                else:\n                    dp[i][j][k] = max(dp[i - 1][j][k], dp[i][j - 1][k], dp[i][j][k - 1])\n    \n    # The length of the LCS of the three strings is in dp[n][n2][n3]\n    return dp[n][n2][n3]"
  },
  {
    "id": 148,
    "response": "def capital_words_spaces(s):\n    words = s.split()\n    modified_words = []\n    for word in words:\n        if word[0].isupper():\n            modified_words.append(' ' + word)\n        else:\n            modified_words.append(word)\n    return ''.join(modified_words)"
  },
  {
    "id": 149,
    "response": "def sort_numeric_strings(lst):\n    # Convert each string in the list to an integer\n    int_list = [int(s) for s in lst]\n    \n    # Sort the list of integers\n    sorted_list = sorted(int_list)\n    \n    return sorted_list"
  },
  {
    "id": 150,
    "response": "def add_tuple(lst, tup):\n    # Determine the length of the shorter list/tuple\n    min_length = min(len(lst), len(tup))\n    \n    # Create a new list to store the results\n    result = []\n    \n    # Iterate over the range of the shorter length\n    for i in range(min_length):\n        # Sum the corresponding elements from the list and tuple\n        result.append(lst[i] + tup[i])\n    \n    return result"
  },
  {
    "id": 151,
    "response": "def check_min_heap(lst, n):\n    for i in range(n // 2):\n        if 2 * i + 1 < n and lst[i] > lst[2 * i + 1]:\n            return False\n        if 2 * i + 2 < n and lst[i] > lst[2 * i + 2]:\n            return False\n    return True"
  },
  {
    "id": 152,
    "response": "def jacobsthal_num(n):\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        a, b = 0, 1\n        for _ in range(2, n + 1):\n            a, b = b, 2 * b + a\n        return b"
  },
  {
    "id": 153,
    "response": "def min_k(lst, k):\n    # Sort the list of tuples based on the first element of each tuple\n    sorted_lst = sorted(lst, key=lambda x: x[0])\n    # Return the first k elements from the sorted list\n    return sorted_lst[:k]"
  },
  {
    "id": 154,
    "response": "def extract_index_list(lst, lst2, lst3):\n    # Convert lists to sets\n    set1 = set(lst)\n    set2 = set(lst2)\n    set3 = set(lst3)\n    \n    # Find intersection of all three sets\n    common_elements = set1.intersection(set2, set3)\n    \n    # Return the common elements as a list\n    return list(common_elements)"
  },
  {
    "id": 155,
    "response": "def second_smallest(lst):\n    if len(lst) < 2:\n        raise ValueError(\"List must contain at least two elements\")\n    \n    first, second = float('inf'), float('inf')\n    \n    for num in lst:\n        if num < first:\n            second = first\n            first = num\n        elif first < num < second:\n            second = num\n    \n    if second == float('inf'):\n        raise ValueError(\"List must contain at least two distinct elements\")\n    \n    return second"
  },
  {
    "id": 156,
    "response": "def text_match_zero_one(s):\n    # Check if the string contains '0' or 'B'\n    if '0' in s or 'B' in s:\n        return True\n    else:\n        return False"
  },
  {
    "id": 157,
    "response": "def count_reverse_pairs(lst):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i + 1, len(lst)):\n            if lst[i] == lst[j][::-1]:\n                count += 1\n    return count"
  },
  {
    "id": 158,
    "response": "def unique_sublists(lst):\n    def generate_sublists(subset, start):\n        if start == len(lst):\n            all_sublists.append(subset)\n            return\n        generate_sublists(subset + [lst[start]], start + 1)\n        generate_sublists(subset, start + 1)\n    \n    all_sublists = []\n    generate_sublists([], 0)\n    unique_sublists = set(tuple(sublist) for sublist in all_sublists)\n    return len(unique_sublists)"
  },
  {
    "id": 159,
    "response": "def is_decimal(s):\n    if not s:\n        return False\n    \n    parts = s.split('.')\n    \n    if len(parts) != 2:\n        return False\n    \n    integer_part, decimal_part = parts\n    \n    if not integer_part.isdigit():\n        return False\n    \n    if not decimal_part.isdigit() or len(decimal_part) > 2:\n        return False\n    \n    return True"
  },
  {
    "id": 160,
    "response": ""
  },
  {
    "id": 161,
    "response": "def arc_length(n, n2):\n    # Convert angle from degrees to radians\n    angle_in_radians = n2 * (math.pi / 180)\n    # Calculate the arc length\n    arc_length = n * angle_in_radians\n    return arc_length"
  },
  {
    "id": 162,
    "response": "def check_monthnumber_number(n):\n    # List of months with exactly 30 days\n    months_with_30_days = [4, 6, 9, 11]\n    \n    # Check if the input month number is in the list\n    if n in months_with_30_days:\n        return True\n    else:\n        return False"
  },
  {
    "id": 163,
    "response": "def find_Min_Diff(arr, n):\n    # Sort the array\n    arr.sort()\n    \n    # Initialize the minimum difference to a large number\n    min_diff = float('inf')\n    \n    # Iterate through the sorted array and calculate the difference between consecutive elements\n    for i in range(1, n):\n        diff = arr[i] - arr[i - 1]\n        if diff < min_diff:\n            min_diff = diff\n    \n    return min_diff"
  },
  {
    "id": 164,
    "response": "def number_ctr(s):\n    count = 0\n    for char in s:\n        if char.isdigit():\n            count += 1\n    return count"
  },
  {
    "id": 165,
    "response": "def is_polite(n):\n    # Check if n is a power of two\n    if n and not(n & (n - 1)):\n        return False\n    return True"
  },
  {
    "id": 166,
    "response": "def pair_wise(lst):\n    result = []\n    for i in range(len(lst)):\n        if i == len(lst) - 1:\n            result.append((lst[i], None))\n        else:\n            result.append((lst[i], lst[i + 1]))\n    return result"
  },
  {
    "id": 167,
    "response": "def get_Pairs_Count(lst, n, n2):\n    count = 0\n    if len(lst) < 2:\n        return count\n    for i in range(len(lst)):\n        for j in range(i + 1, len(lst)):\n            if lst[i] + lst[j] == n2:\n                count += 1\n    return count"
  },
  {
    "id": 168,
    "response": "def check_Odd_Parity(n):\n    n ^= n >> 1\n    n ^= n >> 2\n    n ^= n >> 4\n    n ^= n >> 8\n    n ^= n >> 16\n    # For 64-bit integers\n    n ^= n >> 32\n    return n & 1"
  },
  {
    "id": 169,
    "response": "def diff(lst, lst2):\n    set1 = set(lst)\n    set2 = set(lst2)\n    return list(set1.difference(set2)) + list(set2.difference(set1))"
  },
  {
    "id": 170,
    "response": "def odd_Num_Sum(n):\n    sum_of_powers = 0\n    for i in range(1, n + 1):\n        odd_number = 2 * i - 1\n        sum_of_powers += odd_number ** 4\n    return sum_of_powers"
  },
  {
    "id": 171,
    "response": "def check_expression(s):\n    stack = []\n    bracket_pairs = {')': '(', '}': '{', ']': '['}\n    \n    for char in s:\n        if char in bracket_pairs.values():\n            stack.append(char)\n        elif char in bracket_pairs.keys():\n            if not stack or stack.pop() != bracket_pairs[char]:\n                return False\n    \n    return len(stack) == 0"
  },
  {
    "id": 172,
    "response": "def remove_length(s, n):\n    words = s.split()\n    filtered_words = [word for word in words if len(word) == n]\n    return ' '.join(filtered_words)"
  },
  {
    "id": 173,
    "response": "def occurance_substring(s, s2):\n    positions = []\n    start = 0\n    while True:\n        start = s.find(s2, start)\n        if start == -1:\n            break\n        positions.append(start)\n        start += 1\n    return positions"
  },
  {
    "id": 174,
    "response": "def check_email(s):\n    if len(s) < 5:  # Minimum length for a valid email\n        return False\n    \n    # Split the string at the '@' symbol\n    parts = s.split('@')\n    if len(parts) != 2:\n        return False\n    \n    username, domain = parts\n    \n    # Check username part\n    if not username or not username[0].isalnum():\n        return False\n    for char in username[1:]:\n        if not (char.isalnum() or char in \"_.\"):\n            return False\n    \n    # Check domain part\n    if not domain or not domain[0].isalnum():\n        return False\n    for char in domain[1:]:\n        if not (char.isalnum() or char == '-'):\n            return False\n    \n    # Check domain extension\n    if '.' not in domain:\n        return False\n    extension = domain.split('.')[-1]\n    if not extension or not extension.isalnum():\n        return False\n    \n    return True"
  },
  {
    "id": 175,
    "response": "def odd_position(lst):\n    for index, number in enumerate(lst):\n        if index % 2 == 0:\n            print(f\"{number} is at an odd position (index {index})\")\n        else:\n            print(f\"{number} is not at an odd position (index {index})\")"
  },
  {
    "id": 176,
    "response": "def count_vowels(s):\n    vowels = set('aeiouAEIOU')\n    count = 0\n    for char in s:\n        if char in vowels:\n            count += 1\n    return count"
  },
  {
    "id": 177,
    "response": "def find_Sum(lst, n):\n    # Convert the list to a set to remove duplicates\n    unique_elements = set(lst)\n    # Sum the elements of the set\n    total_sum = sum(unique_elements)\n    return total_sum"
  },
  {
    "id": 178,
    "response": "def pack_consecutive_duplicates(lst):\n    if not lst:\n        return []\n    \n    result = []\n    current_group = [lst[0]]\n    \n    for i in range(1, len(lst)):\n        if lst[i] == current_group[-1]:\n            current_group.append(lst[i])\n        else:\n            result.append(current_group)\n            current_group = [lst[i]]\n    \n    result.append(current_group)\n    return result"
  },
  {
    "id": 179,
    "response": "def unique_sublists(lst):\n    seen = set()\n    unique = []\n    for i in range(len(lst)):\n        for j in range(i + 1, len(lst) + 1):\n            sublist = tuple(lst[i:j])\n            if sublist not in seen:\n                seen.add(sublist)\n                unique.append(sublist)\n    return unique"
  },
  {
    "id": 180,
    "response": "def find_combinations(lst):\n    sums = []\n    for tup in lst:\n        sums.append(sum(tup))\n    return sums"
  },
  {
    "id": 181,
    "response": "def count_Divisors(n):\n    divisors = []\n    for i in range(1, n + 1):\n        if n % i == 0:\n            divisors.append(i)\n    even_count = sum(1 for d in divisors if d % 2 == 0)\n    odd_count = sum(1 for d in divisors if d % 2 != 0)\n    return even_count, odd_count"
  },
  {
    "id": 182,
    "response": "def Odd_Length_Sum(lst):\n    total_sum = 0\n    n = len(lst)\n    \n    # Iterate through all possible starting points of subarrays\n    for start in range(n):\n        # Iterate through all possible ending points of subarrays\n        for end in range(start, n):\n            # Check if the length of the subarray is odd\n            if (end - start + 1) % 2 != 0:\n                # Sum the elements of the subarray\n                subarray_sum = sum(lst[start:end+1])\n                # Add the sum to the total sum\n                total_sum += subarray_sum\n    \n    return total_sum"
  },
  {
    "id": 183,
    "response": "def rgb_to_hsv(r, g, b):\n    # Normalize RGB values to the range [0, 1]\n    r, g, b = r / 255.0, g / 255.0, b / 255.0\n    \n    # Calculate the maximum and minimum values\n    max_val = max(r, g, b)\n    min_val = min(r, g, b)\n    \n    # Calculate the value (V)\n    v = max_val\n    \n    # Calculate the chroma (C)\n    c = max_val - min_val\n    \n    # Calculate the saturation (S)\n    if max_val == 0:\n        s = 0\n    else:\n        s = c / max_val\n    \n    # Calculate the hue (H)\n    if c == 0:\n        h = 0\n    elif max_val == r:\n        h = (60 * ((g - b) / c) + 360) % 360\n    elif max_val == g:\n        h = (60 * ((b - r) / c) + 120) % 360\n    else:\n        h = (60 * ((r - g) / c) + 240) % 360\n    \n    return h, s, v"
  },
  {
    "id": 184,
    "response": "def mul_even_odd(lst):\n    even_found = False\n    odd_found = False\n    even_number = None\n    odd_number = None\n    \n    for num in lst:\n        if num % 2 == 0 and not even_found:\n            even_number = num\n            even_found = True\n        elif num % 2 != 0 and not odd_found:\n            odd_number = num\n            odd_found = True\n        \n        if even_found and odd_found:\n            break\n    \n    if even_found and odd_found:\n        return even_number * odd_number\n    else:\n        raise ValueError(\"List must contain at least one even and one odd number\")"
  },
  {
    "id": 185,
    "response": "def tuple_str_int(s):\n    # Convert each string in the tuple to an integer\n    result = tuple(int(element) for element in s)\n    return result"
  },
  {
    "id": 186,
    "response": ""
  },
  {
    "id": 187,
    "response": "def text_match_three(s):\n    return 'abbb' in s"
  },
  {
    "id": 188,
    "response": "def new_tuple(lst, s):\n    new_tup = ()\n    for item in lst:\n        new_tup += (item,)\n    new_tup += (s,)\n    return new_tup"
  },
  {
    "id": 189,
    "response": "def perimeter_polygon(n, n2):\n    return n * n2"
  },
  {
    "id": 190,
    "response": "def even_position(lst):\n    result = []\n    for i in range(len(lst)):\n        if i % 2 == 0:\n            result.append(lst[i] % 2 == 0)\n        else:\n            result.append(False)\n    return result"
  },
  {
    "id": 191,
    "response": "def remove_nested(tup):\n    result = []\n    for item in tup:\n        if isinstance(item, tuple):\n            continue\n        result.append(item)\n    return tuple(result)"
  },
  {
    "id": 192,
    "response": "def count_list(lst):\n    return len(lst)"
  },
  {
    "id": 193,
    "response": "def last(lst, n, n2):\n    low = 0\n    high = len(lst) - 1\n    result = -1\n    \n    while low <= high:\n        mid = (low + high) // 2\n        if lst[mid] == n2:\n            result = mid\n            low = mid + 1\n        elif lst[mid] < n2:\n            low = mid + 1\n        else:\n            high = mid - 1\n    \n    return result"
  },
  {
    "id": 194,
    "response": "def text_starta_endb(s):\n    if s.startswith('a') and s.endswith('b'):\n        return True\n    else:\n        return False"
  },
  {
    "id": 195,
    "response": "def cheap_items(lst, n):\n    # Sort the list in ascending order\n    sorted_lst = sorted(lst)\n    # Return the first n elements\n    return sorted_lst[:n]"
  },
  {
    "id": 196,
    "response": "def return_sum(dct):\n    total_sum = 0\n    for value in dct.values():\n        total_sum += value\n    return total_sum"
  },
  {
    "id": 197,
    "response": "def sum_in_Range(l, r):\n    total_sum = 0\n    for num in range(l, r + 1):\n        if num % 2 != 0:\n            total_sum += num\n    return total_sum"
  },
  {
    "id": 198,
    "response": "def _sum(lst):\n    return sum(lst)"
  },
  {
    "id": 199,
    "response": ""
  },
  {
    "id": 200,
    "response": ""
  },
  {
    "id": 201,
    "response": "def test_three_equal(n, n2, n3):\n    if n == n2 == n3:\n        return 1\n    else:\n        return 0"
  },
  {
    "id": 202,
    "response": "def count_Rotation(lst, n):\n    rotations = 0\n    for i in range(1, n):\n        if lst[i] < lst[i - 1]:\n            rotations += 1\n    return rotations"
  },
  {
    "id": 203,
    "response": "def is_Perfect_Square(n):\n    if n < 0:\n        return False\n    sqrt_n = int(n ** 0.5)\n    return sqrt_n * sqrt_n == n"
  },
  {
    "id": 204,
    "response": "def is_Product_Even(lst, n):\n    for i in range(n):\n        if lst[i] % 2 == 0:\n            return True\n    return False"
  },
  {
    "id": 205,
    "response": ""
  },
  {
    "id": 206,
    "response": "def max_run_uppercase(s):\n    max_count = 0\n    current_count = 0\n    \n    for char in s:\n        if char.isupper():\n            current_count += 1\n            max_count = max(max_count, current_count)\n        else:\n            current_count = 0\n    \n    return max_count"
  },
  {
    "id": 207,
    "response": "def first_odd(lst):\n    for num in lst:\n        if num % 2 != 0:\n            return num\n    return None  # Return None if no odd number is found"
  },
  {
    "id": 208,
    "response": "def check_K(tup, k):\n    return k in tup"
  },
  {
    "id": 209,
    "response": "def check_smaller(tup, tup2):\n    if len(tup) != len(tup2):\n        return False\n    for i in range(len(tup)):\n        if tup[i] <= tup2[i]:\n            return False\n    return True"
  },
  {
    "id": 210,
    "response": "def count_variable(n, n2, n3, n4):\n    # Initialize a dictionary to store the count of each variable\n    variable_count = {'n': 0, 'n2': 0, 'n3': 0, 'n4': 0}\n    \n    # Convert the function body to a string\n    function_body = count_variable.__code__.co_code\n    \n    # Count the occurrences of each variable in the function body\n    for var in variable_count:\n        variable_count[var] = function_body.count(var.encode())\n    \n    return variable_count"
  },
  {
    "id": 211,
    "response": "def check_identical(lst, lst2):\n    # Check if both lists have the same length\n    if len(lst) != len(lst2):\n        return False\n    \n    # Iterate through each tuple in the lists and compare them\n    for i in range(len(lst)):\n        if lst[i] != lst2[i]:\n            return False\n    \n    return True"
  },
  {
    "id": 212,
    "response": "def road_rd(s):\n    return s.replace('road', 'rd.')"
  },
  {
    "id": 213,
    "response": "def string_length(s):\n    return len(s)"
  },
  {
    "id": 214,
    "response": "def rhombus_area(n, n2):\n    return 0.5 * n * n2"
  },
  {
    "id": 215,
    "response": "def sort_by_dnf(lst, n):\n    low = 0\n    mid = 0\n    high = n - 1\n    \n    while mid <= high:\n        if lst[mid] == 0:\n            lst[low], lst[mid] = lst[mid], lst[low]\n            low += 1\n            mid += 1\n        elif lst[mid] == 1:\n            mid += 1\n        else:\n            lst[mid], lst[high] = lst[high], lst[mid]\n            high -= 1\n    \n    return lst"
  },
  {
    "id": 216,
    "response": "def clear_tuple(tup):\n    # Create a new tuple with the same length as the original tuple but with empty values\n    cleared_tup = tuple(None for _ in tup)\n    return cleared_tup"
  },
  {
    "id": 217,
    "response": "def div_of_nums(lst, n, n2):\n    # Use filter with a lambda function to find numbers divisible by n or n2\n    result = list(filter(lambda x: (x % n == 0 or x % n2 == 0), lst))\n    return result"
  },
  {
    "id": 218,
    "response": "def lower_ctr(s):\n    count = 0\n    for char in s:\n        if char.islower():\n            count += 1\n    return count"
  },
  {
    "id": 219,
    "response": "def count_duplic(lst):\n    if len(lst) <= 1:\n        return 0\n    \n    count = 0\n    for i in range(len(lst) - 1):\n        if lst[i] == lst[i + 1]:\n            count += 1\n    \n    return count"
  },
  {
    "id": 220,
    "response": "def check_monthnum_number(n):\n    if n == 2:\n        # Check if the year is a leap year\n        year = 2023  # Assuming the current year for simplicity\n        if (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0):\n            return 29\n        else:\n            return 28\n    else:\n        return 30  # Assuming other months have 30 days for simplicity"
  },
  {
    "id": 221,
    "response": "def merge_dictionaries(dct, dct2):\n    result = dct.copy()  # Create a copy of the first dictionary to avoid modifying the original\n    result.update(dct2)  # Update the copy with the second dictionary\n    return result"
  },
  {
    "id": 222,
    "response": "def pass_validity(s):\n    if len(s) < 8:\n        return False\n    has_upper = any(char.isupper() for char in s)\n    has_lower = any(char.islower() for char in s)\n    has_digit = any(char.isdigit() for char in s)\n    has_special = any(not char.isalnum() for char in s)\n    return has_upper and has_lower and has_digit and has_special"
  },
  {
    "id": 223,
    "response": "def check_substring(s, s2):\n    return s.startswith(s2)"
  },
  {
    "id": 224,
    "response": "def remove_even(lst):\n    return [num for num in lst if num % 2 != 0]"
  },
  {
    "id": 225,
    "response": "def access_elements(lst, lst2):\n    result = []\n    for index in lst2:\n        if 0 <= index < len(lst):\n            result.append(lst[index])\n    return result"
  },
  {
    "id": 226,
    "response": "def check_Type_Of_Triangle(n, n2, n3):\n    # Check if the sides can form a triangle\n    if n + n2 > n3 and n + n3 > n2 and n2 + n3 > n:\n        if n == n2 == n3:\n            return \"Equilateral\"\n        elif n == n2 or n == n3 or n2 == n3:\n            return \"Isosceles\"\n        else:\n            return \"Scalene\"\n    else:\n        return \"Not a Triangle\""
  },
  {
    "id": 227,
    "response": "def sum_column(lst, n):\n    if not lst or n < 0 or n >= len(lst[0]):\n        raise ValueError(\"Invalid input\")\n    \n    total_sum = 0\n    for row in lst:\n        total_sum += row[n]\n    \n    return total_sum"
  },
  {
    "id": 228,
    "response": "def count_alpha_dig_spl(s):\n    alpha_count = 0\n    digit_count = 0\n    spl_count = 0\n    \n    for char in s:\n        if char.isalpha():\n            alpha_count += 1\n        elif char.isdigit():\n            digit_count += 1\n        else:\n            spl_count += 1\n    \n    return alpha_count, digit_count, spl_count"
  },
  {
    "id": 229,
    "response": "def second_frequent(lst):\n    from collections import Counter\n    # Count the frequency of each string\n    frequency = Counter(lst)\n    # Sort the strings by frequency in descending order\n    sorted_frequency = sorted(frequency.items(), key=lambda x: x[1], reverse=True)\n    # Return the second most frequent string\n    return sorted_frequency[1][0]"
  },
  {
    "id": 230,
    "response": ""
  },
  {
    "id": 231,
    "response": "def count_Pairs(lst, n):\n    from collections import Counter\n    \n    # Count the frequency of each element in the list\n    count_dict = Counter(lst)\n    \n    # Calculate the number of pairs\n    pairs = 0\n    for key, value in count_dict.items():\n        pairs += value * (value - 1) // 2\n    \n    return pairs"
  },
  {
    "id": 232,
    "response": "def extract_max(s):\n    # Find all sequences of digits in the string\n    numbers = re.findall(r'\\d+', s)\n    # Convert the found sequences to integers\n    numbers = [int(num) for num in numbers]\n    # Return the maximum value\n    return max(numbers)"
  },
  {
    "id": 233,
    "response": "def get_key(dct):\n    return list(dct.keys())"
  },
  {
    "id": 234,
    "response": "def generate_matrix(n):\n    if n <= 0:\n        return []\n    \n    # Initialize an empty n x n matrix\n    matrix = [[0] * n for _ in range(n)]\n    \n    # Define the boundaries\n    top, bottom = 0, n - 1\n    left, right = 0, n - 1\n    \n    # Initialize the number to be filled\n    num = 1\n    \n    while top <= bottom and left <= right:\n        # Fill the top row\n        for i in range(left, right + 1):\n            matrix[top][i] = num\n            num += 1\n        top += 1\n        \n        # Fill the right column\n        for i in range(top, bottom + 1):\n            matrix[i][right] = num\n            num += 1\n        right -= 1\n        \n        # Fill the bottom row\n        if top <= bottom:\n            for i in range(right, left - 1, -1):\n                matrix[bottom][i] = num\n                num += 1\n            bottom -= 1\n        \n        # Fill the left column\n        if left <= right:\n            for i in range(bottom, top - 1, -1):\n                matrix[i][left] = num\n                num += 1\n            left += 1\n    \n    return matrix"
  },
  {
    "id": 235,
    "response": ""
  },
  {
    "id": 236,
    "response": "def max_sub_array_sum(lst, n):\n    if len(lst) < n:\n        return None  # Not enough elements to form a sub-array of length n\n    \n    # Initialize the maximum sum with the sum of the first sub-array of length n\n    max_sum = sum(lst[:n])\n    current_sum = max_sum\n    \n    # Use a sliding window to compute the sum of sub-arrays of length n\n    for i in range(n, len(lst)):\n        current_sum += lst[i] - lst[i - n]\n        max_sum = max(max_sum, current_sum)\n    \n    return max_sum"
  },
  {
    "id": 237,
    "response": "def cube_Sum(n):\n    total_sum = 0\n    for i in range(1, n + 1):\n        total_sum += i ** 3\n    return total_sum"
  },
  {
    "id": 238,
    "response": "def min_Swaps(s, s2):\n    # Check if the lengths of the strings are equal\n    if len(s) != len(s2):\n        return -1\n    \n    # Count the number of '0's and '1's in both strings\n    count_s = {'0': 0, '1': 0}\n    count_s2 = {'0': 0, '1': 0}\n    \n    for char in s:\n        count_s[char] += 1\n    for char in s2:\n        count_s2[char] += 1\n    \n    # If the counts of '0's and '1's do not match, return -1\n    if count_s['0'] != count_s2['0'] or count_s['1'] != count_s2['1']:\n        return -1\n    \n    # Calculate the number of swaps needed\n    swaps = 0\n    i = 0\n    while i < len(s):\n        if s[i] != s2[i]:\n            j = i + 1\n            while j < len(s) and s[j] != s[i]:\n                j += 1\n            if j == len(s):\n                return -1\n            # Swap the characters\n            s = s[:i] + s[j] + s[i+1:j] + s[i] + s[j+1:]\n            swaps += 1\n        i += 1\n    \n    return swaps"
  },
  {
    "id": 239,
    "response": "def sort_tuple(lst):\n    return sorted(lst, key=lambda x: x[0])"
  },
  {
    "id": 240,
    "response": "def Check_Solution(n, n2, n3, n4):\n    return n + n4 == n2 + n3"
  },
  {
    "id": 241,
    "response": "def merge_and_count(arr, temp_arr, left, mid, right):\n    i = left    # Starting index for left subarray\n    j = mid + 1 # Starting index for right subarray\n    k = left    # Starting index to be sorted\n    inv_count = 0"
  },
  {
    "id": 242,
    "response": "def get_odd_occurence(lst, n):\n    count_dict = {}\n    for num in lst:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    \n    for num, count in count_dict.items():\n        if count % 2 != 0:\n            return num"
  },
  {
    "id": 243,
    "response": "def nth_super_ugly_number(n, primes):\n    if n <= 0:\n        return None\n    if n == 1:\n        return 1\n    \n    heap = [1]\n    seen = {1}\n    \n    for _ in range(1, n):\n        current = heapq.heappop(heap)\n        for prime in primes:\n            next_ugly = current * prime\n            if next_ugly not in seen:\n                seen.add(next_ugly)\n                heapq.heappush(heap, next_ugly)\n    \n    return heapq.heappop(heap)"
  },
  {
    "id": 244,
    "response": "def get_Number(n, n2, k):\n    # Generate an array of unique elements between n and n2\n    elements = list(range(n, n2 + 1))\n    \n    # Sort the array in ascending order (although it's already sorted)\n    elements.sort()\n    \n    # Return the kth element (1-based index)\n    return elements[k - 1]"
  },
  {
    "id": 245,
    "response": "def find_Digits(n):\n    if n == 0:\n        return 1\n    return math.floor(math.log10(math.sqrt(2 * math.pi * n) * (n / math.e) ** n)) + 1"
  },
  {
    "id": 246,
    "response": "def find_platform(arr, dep, n):\n    # Sort the arrival and departure times\n    arr.sort()\n    dep.sort()\n    \n    # Initialize variables\n    plat_needed = 1\n    result = 1\n    i = 1\n    j = 0\n    \n    # Iterate through the trains\n    while i < n and j < n:\n        # If the next train arrives before the current train departs, increment platform count\n        if arr[i] <= dep[j]:\n            plat_needed += 1\n            i += 1\n            # Update the result if more platforms are needed\n            if plat_needed > result:\n                result = plat_needed\n        # If the next train departs before the current train arrives, decrement platform count\n        else:\n            plat_needed -= 1\n            j += 1\n    \n    return result"
  },
  {
    "id": 247,
    "response": "def lcopy(lst):\n    # Access the first (and only) element of the singleton tuple\n    original_list = lst[0]\n    # Create a copy of the list\n    copied_list = original_list[:]\n    return copied_list"
  },
  {
    "id": 248,
    "response": "def area_trapezium(n, n2, n3):\n    return 0.5 * (n + n2) * n3"
  },
  {
    "id": 249,
    "response": "def sum_of_divisors(n):\n    if n <= 0:\n        return 0\n    divisor_sum = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            divisor_sum += i\n    return divisor_sum"
  },
  {
    "id": 250,
    "response": "def is_triangle_exists(n, n2, n3):\n    # Check the triangle inequality theorem\n    if (n + n2 > n3) and (n + n3 > n2) and (n2 + n3 > n):\n        return True\n    else:\n        return False"
  },
  {
    "id": 251,
    "response": "def sum_of_inverse_divisors(n):\n    sum_inverses = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            sum_inverses += 1 / i\n    return sum_inverses"
  },
  {
    "id": 252,
    "response": "def remove_negs(lst):\n    return [num for num in lst if num >= 0]"
  },
  {
    "id": 253,
    "response": "def sum_of_odd_factors(n):\n    sum_odd = 0\n    for i in range(1, n + 1):\n        if i % 2 != 0 and n % i == 0:\n            sum_odd += i\n    return sum_odd"
  },
  {
    "id": 254,
    "response": "def raw_heap(lst):\n    heapq.heapify(lst)\n    return lst"
  },
  {
    "id": 255,
    "response": "def check_Even_Parity(n):\n    # Convert the number to binary and remove the '0b' prefix\n    binary_representation = bin(n)[2:]\n    \n    # Count the number of 1s in the binary representation\n    count_of_ones = binary_representation.count('1')\n    \n    # Check if the count of 1s is even\n    if count_of_ones % 2 == 0:\n        return True\n    else:\n        return False"
  },
  {
    "id": 256,
    "response": "def find_Min_Swaps(lst, n):\n    count_0 = lst.count(0)\n    misplaced_0 = 0\n    \n    for i in range(n):\n        if lst[i] == 0 and i >= count_0:\n            misplaced_0 += 1\n    \n    return misplaced_0"
  },
  {
    "id": 257,
    "response": "def listify_list(lst):\n    result = []\n    for item in lst:\n        result.append([item])\n    return result"
  },
  {
    "id": 258,
    "response": "def count_list(lst):\n    result = []\n    for sublist in lst:\n        square_sum = sum(x**2 for x in sublist)\n        result.append(square_sum)\n    return result"
  },
  {
    "id": 259,
    "response": "def sub_lists(lst):\n    if not lst:\n        return [[]]\n    first, *rest = lst\n    sublists_without_first = sub_lists(rest)\n    sublists_with_first = [[first] + sublist for sublist in sublists_without_first]\n    return sublists_without_first + sublists_with_first"
  },
  {
    "id": 260,
    "response": "def check_alphanumeric(s):\n    for i in range(len(s) - 1, -1, -1):\n        if not s[i].isalpha():\n            return False\n    return True"
  },
  {
    "id": 261,
    "response": "def anagram_lambda(lst, s):\n    # Generate all permutations of the target string s\n    perms = [''.join(p) for p in permutations(s)]\n    \n    # Filter the list to include only anagrams of s\n    anagrams = [word for word in lst if word in perms]\n    \n    return anagrams"
  },
  {
    "id": 262,
    "response": ""
  },
  {
    "id": 263,
    "response": "def find_longest_conseq_subseq(lst, n):\n    num_set = set(lst)\n    longest_streak = 0"
  },
  {
    "id": 264,
    "response": "def palindrome_lambda(lst):\n    is_palindrome = lambda s: s == s[::-1]\n    return list(filter(is_palindrome, lst))"
  },
  {
    "id": 265,
    "response": "def ntimes_list(lst, n):\n    if n <= 0:\n        return\n    for _ in range(n):\n        print(lst)"
  },
  {
    "id": 266,
    "response": "def check_monthnumb(s):\n    # List of months with 31 days\n    months_with_31_days = [\"January\", \"March\", \"May\", \"July\", \"August\", \"October\", \"December\"]\n    \n    # Check if the given month is in the list\n    if s in months_with_31_days:\n        return True\n    else:\n        return False"
  },
  {
    "id": 267,
    "response": "def min_Num(lst, n):\n    current_sum = sum(lst)\n    remainder = current_sum % n\n    if remainder == 0:\n        return 0\n    else:\n        return n - remainder"
  },
  {
    "id": 268,
    "response": "def length_of_last_word(s):\n    # Strip leading and trailing whitespace\n    s = s.strip()\n    \n    # Split the string into words\n    words = s.split()\n    \n    # Get the last word\n    last_word = words[-1]\n    \n    # Return the length of the last word\n    return len(last_word)"
  },
  {
    "id": 269,
    "response": "def remove_list_range(lst, n, n2):\n    # Create a new list to store elements that are not in the specified range\n    new_lst = [x for x in lst if x < n or x > n2]\n    return new_lst"
  },
  {
    "id": 270,
    "response": "def sum_positivenum(lst):\n    positive_nums = list(filter(lambda x: x > 0, lst))\n    return sum(positive_nums)"
  },
  {
    "id": 271,
    "response": "def are_Rotations(s, s2):\n    if len(s) != len(s2):\n        return False\n    temp = s + s\n    return s2 in temp"
  },
  {
    "id": 272,
    "response": "def check_subset(lst, lst2):\n    for item in lst:\n        if item not in lst2:\n            return False\n    return True"
  },
  {
    "id": 273,
    "response": "def fibonacci(n):\n    if n <= 1:\n        return n\n    else:\n        return fibonacci(n-1) + fibonacci(n-2)"
  },
  {
    "id": 274,
    "response": "def check_Concat(s, s2):\n    while s.startswith(s2):\n        s = s[len(s2):]\n    return s == \"\""
  },
  {
    "id": 275,
    "response": "def min_difference(lst):\n    min_diff = float('inf')  # Initialize with infinity to ensure any difference is smaller\n    for i in range(len(lst)):\n        for j in range(i + 1, len(lst)):\n            diff = abs(lst[i][0] - lst[j][0])  # Calculate the difference between the first elements\n            if diff < min_diff:\n                min_diff = diff\n    return min_diff"
  },
  {
    "id": 276,
    "response": "def lcm(n, n2):\n    return abs(n * n2) // math.gcd(n, n2)"
  },
  {
    "id": 277,
    "response": "def sort_String(s):\n    return ''.join(sorted(s))"
  },
  {
    "id": 278,
    "response": "def check_tuples(tup, k):\n    return len(tup) == k"
  },
  {
    "id": 279,
    "response": "def text_match(s):\n    pattern = '.*a.*b$'\n    if re.search(pattern, s):\n        return True\n    else:\n        return False"
  },
  {
    "id": 280,
    "response": "def Check_Solution(n, n2, n3):\n    discriminant = n2**2 - 4*n*n3\n    if discriminant > 0:\n        return 2\n    elif discriminant == 0:\n        return 1\n    else:\n        return 0"
  },
  {
    "id": 281,
    "response": "def sum_even_odd(lst):\n    even_sum = 0\n    odd_sum = 0\n    for num in lst:\n        if num % 2 == 0:\n            even_sum += num\n        else:\n            odd_sum += num\n    return even_sum + odd_sum"
  },
  {
    "id": 282,
    "response": "def parallelogram_perimeter(n, n2):\n    return 2 * (n + n2)"
  },
  {
    "id": 283,
    "response": "def div_of_nums(lst, m, n):\n    return list(filter(lambda x: x % m == 0 and x % n == 0, lst))"
  },
  {
    "id": 284,
    "response": "def all_Bits_Set_In_The_Given_Range(n, n2, n3):\n    # Create a mask with all bits set in the range [n2, n3]\n    mask = ((1 << (n3 + 1)) - 1) ^ ((1 << n2) - 1)\n    \n    # Use bitwise AND operation to check if all bits in the range are set\n    if n & mask == mask:\n        return True\n    else:\n        return False"
  },
  {
    "id": 285,
    "response": "def is_isomorphic(s, s2):\n    if len(s) != len(s2):\n        return False\n    \n    char_map = {}\n    used_chars = set()\n    \n    for char1, char2 in zip(s, s2):\n        if char1 in char_map:\n            if char_map[char1] != char2:\n                return False\n        else:\n            if char2 in used_chars:\n                return False\n            char_map[char1] = char2\n            used_chars.add(char2)\n    \n    return True"
  },
  {
    "id": 286,
    "response": "def sum_num(lst):\n    total_sum = sum(lst)\n    length = len(lst)\n    result = total_sum / length\n    return result"
  },
  {
    "id": 287,
    "response": ""
  },
  {
    "id": 288,
    "response": "def substract_elements(tup, tup2):\n    result = tuple(tuple(b - a for a, b in zip(inner_tup1, inner_tup2))\n                   for inner_tup1, inner_tup2 in zip(tup, tup2))\n    return result"
  },
  {
    "id": 289,
    "response": "def reverse_list_lists(lst):\n    return [sublist[::-1] for sublist in lst]"
  },
  {
    "id": 290,
    "response": "def find_Extra(lst, lst2, n):\n    for i in range(n):\n        if lst[i] not in lst2:\n            return i\n    return -1"
  },
  {
    "id": 291,
    "response": "def same_Length(n, n2):\n    return len(str(n)) == len(str(n2))"
  },
  {
    "id": 292,
    "response": "def remove_spaces(s):\n    return re.sub(r'\\s+', ' ', s)"
  },
  {
    "id": 293,
    "response": "def Extract(lst):\n    # Initialize an empty list to store the last elements\n    result = []\n    # Iterate through each sublist in the given list\n    for sublist in lst:\n        # Append the last element of the sublist to the result list\n        result.append(sublist[-1])\n    return result"
  },
  {
    "id": 294,
    "response": "def float_to_tuple(s):\n    # Split the string by the decimal point\n    parts = s.split('.')\n    \n    # Convert the integer part to an integer\n    integer_part = int(parts[0])\n    \n    # Convert the fractional part to an integer\n    fractional_part = int(parts[1])\n    \n    # Combine the integer and fractional parts into a tuple\n    result = (integer_part, fractional_part)\n    \n    return result"
  },
  {
    "id": 295,
    "response": "def max_sum_subseq(lst):\n    if not lst:\n        return 0\n    \n    max_current = max_global = lst[0]\n    \n    for num in lst[1:]:\n        max_current = max(num, max_current + num)\n        if max_current > max_global:\n            max_global = max_current\n    \n    return max_global"
  },
  {
    "id": 296,
    "response": "def sort_list_last(lst):\n    return sorted(lst, key=lambda x: x[-1])"
  },
  {
    "id": 297,
    "response": "def is_Word_Present(s, s2):\n    return s2 in s"
  },
  {
    "id": 298,
    "response": "def extract_elements(lst, n):\n    if n > len(lst):\n        return lst\n    elif n == 0:\n        return []\n    else:\n        return lst[:n]"
  },
  {
    "id": 299,
    "response": "def can_partition(lst, n):\n    total_sum = sum(lst)\n    if total_sum % 2 != 0:\n        return False\n    target = total_sum // 2\n    dp = [False] * (target + 1)\n    dp[0] = True\n    for num in lst:\n        for j in range(target, num - 1, -1):\n            dp[j] = dp[j] or dp[j - num]\n    return dp[target]"
  },
  {
    "id": 300,
    "response": "def match_num(s, num):\n    return s.startswith(str(num))"
  },
  {
    "id": 301,
    "response": "def num_comm_div(n, n2):\n    while n2:\n        n, n2 = n2, n % n2\n    return n"
  },
  {
    "id": 302,
    "response": "def find(n, n2):\n    return n % n2"
  },
  {
    "id": 303,
    "response": "def add_consecutive_nums(lst):\n    total_sum = 0\n    for num in lst:\n        total_sum += num\n    return total_sum"
  },
  {
    "id": 304,
    "response": "def sum_of_series(n):\n    return n * (n + 1) * (2 * n + 1) // 6"
  },
  {
    "id": 305,
    "response": "def re_order(lst):\n    non_zero_index = 0\n    for i in range(len(lst)):\n        if lst[i] != 0:\n            lst[non_zero_index] = lst[i]\n            non_zero_index += 1\n    for i in range(non_zero_index, len(lst)):\n        lst[i] = 0\n    return lst"
  },
  {
    "id": 306,
    "response": "def factorial(num):\n    if num == 0 or num == 1:\n        return 1\n    result = 1\n    for i in range(2, num + 1):\n        result *= i\n    return result"
  },
  {
    "id": 307,
    "response": "def remove_words(lst, lst2):\n    # Create a new list to store words that are not in lst2\n    new_list = []\n    \n    # Iterate through each word in lst\n    for word in lst:\n        # Check if the word is not in lst2\n        if word not in lst2:\n            # If not, add it to the new list\n            new_list.append(word)\n    \n    # Return the new list\n    return new_list"
  },
  {
    "id": 308,
    "response": "def same_order(lst, lst2):\n    if len(lst) != len(lst2):\n        return False\n    for i in range(len(lst)):\n        if lst[i] != lst2[i]:\n            return False\n    return True"
  },
  {
    "id": 309,
    "response": "def average_Odd(n):\n    total_sum = 0\n    count = 0\n    for i in range(1, n + 1):\n        if i % 2 != 0:\n            total_sum += i\n            count += 1\n    if count == 0:\n        return 0  # To avoid division by zero if n is 0 or even\n    return total_sum / count"
  },
  {
    "id": 310,
    "response": "def no_of_subsequences(lst, n):\n    m = len(lst)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    \n    # Initialize the DP table\n    dp[0][0] = 1\n    \n    # Fill the DP table\n    for i in range(1, m + 1):\n        for j in range(n, -1, -1):\n            dp[i][j] = dp[i - 1][j]\n            if j >= lst[i - 1]:\n                dp[i][j] += dp[i - 1][j - lst[i - 1]]\n    \n    # Sum up all valid subsequences\n    result = sum(dp[m][j] for j in range(n + 1))\n    return result"
  },
  {
    "id": 311,
    "response": "def find_Min_Sum(n):\n    factors = [i for i in range(1, n + 1) if n % i == 0]\n    return sum(factors)"
  },
  {
    "id": 312,
    "response": "def count_element_freq(tup):\n    # Flatten the nested tuple\n    flat_list = []\n    for item in tup:\n        if isinstance(item, tuple):\n            flat_list.extend(count_element_freq(item))\n        else:\n            flat_list.append(item)\n    \n    # Count the frequency of each element\n    freq_dict = {}\n    for element in flat_list:\n        if element in freq_dict:\n            freq_dict[element] += 1\n        else:\n            freq_dict[element] = 1\n    \n    return freq_dict"
  },
  {
    "id": 313,
    "response": "def add_str(tup, s):\n    # Use a generator expression to concatenate the string to each element of the tuple\n    result = tuple(element + s for element in tup)\n    return result"
  },
  {
    "id": 314,
    "response": "def sum_elements(tup):\n    total = 0\n    for element in tup:\n        total += element\n    return total"
  },
  {
    "id": 315,
    "response": "def modular_sum(lst, n, n2):\n    from itertools import combinations\n    \n    # Function to check if any subset sum modulo n equals n2\n    def has_subset_with_mod_sum(subset, n, n2):\n        return sum(subset) % n == n2\n    \n    # Check all subsets\n    for r in range(1, len(lst) + 1):\n        for subset in combinations(lst, r):\n            if has_subset_with_mod_sum(subset, n, n2):\n                return True\n    return False"
  },
  {
    "id": 316,
    "response": "def radix_sort(lst):\n    if not lst:\n        return lst"
  },
  {
    "id": 317,
    "response": "def largest_pos(lst):\n    if not lst:\n        return None  # Return None if the list is empty\n    max_value = lst[0]\n    for num in lst:\n        if num > max_value:\n            max_value = num\n    return max_value"
  },
  {
    "id": 318,
    "response": "def sqrt_root(n):\n    if n < 0:\n        raise ValueError(\"Cannot compute the square root of a negative number.\")\n    if n == 0 or n == 1:\n        return n\n    \n    # Initial guess will be half of the number\n    guess = n / 2.0\n    while True:\n        # Newton-Raphson formula to refine the guess\n        new_guess = (guess + n / guess) / 2\n        # Check if the guess is close enough to the actual square root\n        if abs(new_guess - guess) < 1e-10:\n            return new_guess\n        guess = new_guess"
  },
  {
    "id": 319,
    "response": "def volume_tetrahedron(a):\n    return (a ** 3 * (2 ** 0.5)) / 12"
  },
  {
    "id": 320,
    "response": "def get_lcm(lst):\n    if not lst:\n        return None\n    lcm = lst[0]\n    for num in lst[1:]:\n        lcm = abs(lcm * num) // math.gcd(lcm, num)\n    return lcm"
  },
  {
    "id": 321,
    "response": "def check_isosceles(n, n2, n3):\n    if n == n2 or n == n3 or n2 == n3:\n        return True\n    else:\n        return False"
  },
  {
    "id": 322,
    "response": "def lbs(lst):\n    n = len(lst)\n    if n == 0:\n        return 0\n    \n    # Initialize LIS and LDS arrays\n    lis = [1] * n\n    lds = [1] * n\n    \n    # Compute LIS values from left to right\n    for i in range(1, n):\n        for j in range(i):\n            if lst[i] > lst[j] and lis[i] < lis[j] + 1:\n                lis[i] = lis[j] + 1\n    \n    # Compute LDS values from right to left\n    for i in range(n-2, -1, -1):\n        for j in range(i+1, n):\n            if lst[i] > lst[j] and lds[i] < lds[j] + 1:\n                lds[i] = lds[j] + 1\n    \n    # Find the maximum length of bitonic subsequence\n    max_length = 0\n    for i in range(n):\n        max_length = max(max_length, lis[i] + lds[i] - 1)\n    \n    return max_length"
  },
  {
    "id": 323,
    "response": ""
  },
  {
    "id": 324,
    "response": ""
  },
  {
    "id": 325,
    "response": "def parallel_lines(lst, lst2):\n    # Extract the coefficients of x and y from the equations\n    m1 = lst[0] / lst[1]\n    m2 = lst2[0] / lst2[1]\n    \n    # Check if the slopes are equal\n    if m1 == m2:\n        return True\n    else:\n        return False"
  },
  {
    "id": 326,
    "response": "def capitalize_first_last_letters(s):\n    words = s.split()\n    modified_words = []\n    \n    for word in words:\n        if len(word) > 1:\n            modified_word = word[0].upper() + word[1:-1] + word[-1].upper()\n        else:\n            modified_word = word.upper()\n        modified_words.append(modified_word)\n    \n    return ' '.join(modified_words)"
  },
  {
    "id": 327,
    "response": "def get_pairs_count(lst, n, n2):\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if lst[i] + lst[j] == n2:\n                count += 1\n    return count"
  },
  {
    "id": 328,
    "response": "def min_length(lst):\n    if not lst:\n        return None\n    min_len = float('inf')\n    min_list = None\n    for sublist in lst:\n        if len(sublist) < min_len:\n            min_len = len(sublist)\n            min_list = sublist\n    return min_list"
  },
  {
    "id": 329,
    "response": "def jacobsthal_lucas(n):\n    if n == 0:\n        return 2\n    elif n == 1:\n        return 1\n    else:\n        a, b = 2, 1\n        for _ in range(2, n + 1):\n            a, b = b, 2 * b + a\n        return b"
  },
  {
    "id": 330,
    "response": "def negative_count(lst):\n    if not lst:  # Check if the list is empty\n        return 0\n    negative_count = sum(1 for num in lst if num < 0)\n    total_count = len(lst)\n    ratio = negative_count / total_count\n    return ratio"
  },
  {
    "id": 331,
    "response": "def min_coins(lst, n):\n    # Initialize a list to store the minimum coins needed for each amount up to n\n    dp = [float('inf')] * (n + 1)\n    dp[0] = 0  # Base case: 0 coins are needed to make amount 0"
  },
  {
    "id": 332,
    "response": "def check_permutation(s, s2):\n    # Remove any whitespace and convert to lowercase for uniformity\n    s = s.replace(\" \", \"\").lower()\n    s2 = s2.replace(\" \", \"\").lower()\n    \n    # Check if the sorted versions of the strings are equal\n    return sorted(s) == sorted(s2)"
  },
  {
    "id": 333,
    "response": "def remove_datatype(tup, param):\n    # Convert the tuple to a list\n    temp_list = list(tup)\n    \n    # Iterate through the list and remove elements of the specified data type\n    temp_list = [item for item in temp_list if not isinstance(item, param)]\n    \n    # Convert the list back to a tuple and return it\n    return tuple(temp_list)"
  },
  {
    "id": 334,
    "response": "def search_literal(s, s2):\n    return s.find(s2)"
  },
  {
    "id": 335,
    "response": "def topbottom_surfacearea(radius):\n    # Calculate the area of one circular face\n    area_of_one_face = math.pi * (radius ** 2)\n    # Since there are two faces (top and bottom), multiply by 2\n    total_surface_area = 2 * area_of_one_face\n    return total_surface_area"
  },
  {
    "id": 336,
    "response": "def nth_item(lst, n):\n    if n <= 0 or n > len(lst):\n        return None\n    return lst[n-1]"
  },
  {
    "id": 337,
    "response": "def first_repeated_word(s):\n    words = s.split()\n    seen = set()\n    \n    for word in words:\n        if word in seen:\n            return word\n        seen.add(word)\n    \n    return None"
  },
  {
    "id": 338,
    "response": "def string_list_to_tuple(string_list):\n    result = []\n    for index, string in enumerate(string_list):\n        result.append((string, index))\n    return tuple(result)"
  },
  {
    "id": 339,
    "response": "def basesnum_coresspondingnum(lst, lst2):\n    result = []\n    for base, num in zip(lst, lst2):\n        result.append(base ** num)\n    return result"
  },
  {
    "id": 340,
    "response": "def find_Diff(lst, n):\n    # Step 1: Count the frequency of each element\n    frequency = {}\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    \n    # Step 2: Find the maximum and minimum frequencies\n    max_freq = max(frequency.values())\n    min_freq = min(frequency.values())\n    \n    # Step 3: Calculate the difference\n    difference = max_freq - min_freq\n    \n    return difference"
  },
  {
    "id": 341,
    "response": "def check_abundant(n):\n    if n <= 1:\n        return False\n    divisors_sum = sum([i for i in range(1, n) if n % i == 0])\n    return divisors_sum > n"
  },
  {
    "id": 342,
    "response": "def fill_spaces(s):\n    # Use regular expression to find spaces, commas, and periods\n    pattern = r'[ ,.]'\n    # Replace the found characters with 'column'\n    result = re.sub(pattern, 'column', s)\n    return result"
  },
  {
    "id": 343,
    "response": "def count_digits(n, n2):\n    # Step 1: Calculate the sum of the two numbers\n    sum_of_numbers = n + n2\n    \n    # Step 2: Convert the sum to a string to count the digits\n    sum_str = str(sum_of_numbers)\n    \n    # Step 3: Count the number of digits in the sum\n    digit_count = len(sum_str)\n    \n    # Step 4: Return the count of digits\n    return digit_count"
  },
  {
    "id": 344,
    "response": "def flatten_tuple(lst):\n    flattened_list = []\n    for sublist in lst:\n        flattened_list.extend(sublist)\n    return flattened_list"
  },
  {
    "id": 345,
    "response": "def toggle_F_and_L_bits(n):\n    # Get the number of bits in n\n    num_bits = n.bit_length()\n    \n    # Create a mask for the first bit\n    first_bit_mask = 1 << (num_bits - 1)\n    \n    # Create a mask for the last bit\n    last_bit_mask = 1\n    \n    # Toggle the first and last bits\n    n ^= first_bit_mask\n    n ^= last_bit_mask\n    \n    return n"
  },
  {
    "id": 346,
    "response": "def last_occurence_char(s, s2):\n    for i in range(len(s) - 1, -1, -1):\n        if s[i] == s2:\n            return i\n    return -1"
  },
  {
    "id": 347,
    "response": "def total_hamming_distance(n):\n    total_distance = 0\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            xor = i ^ j\n            while xor:\n                total_distance += xor & 1\n                xor >>= 1\n    return total_distance"
  },
  {
    "id": 348,
    "response": "def longest_increasing_subsequence(lst):\n    if not lst:\n        return 0\n    \n    n = len(lst)\n    dp = [1] * n\n    \n    for i in range(1, n):\n        for j in range(i):\n            if lst[i] > lst[j]:\n                dp[i] = max(dp[i], dp[j] + 1)\n    \n    return max(dp)"
  },
  {
    "id": 349,
    "response": "def odd_Num_Sum(n):\n    sum_of_powers = 0\n    for i in range(1, 2*n, 2):\n        sum_of_powers += i**5\n    return sum_of_powers"
  },
  {
    "id": 350,
    "response": "def find_Max(arr, low, high):\n    if low > high:\n        return -1\n    \n    mid = (low + high) // 2\n    \n    if mid < high and arr[mid] > arr[mid + 1]:\n        return arr[mid]\n    \n    if mid > low and arr[mid] < arr[mid - 1]:\n        return arr[mid - 1]\n    \n    if arr[low] == arr[mid] == arr[high]:\n        return max(find_Max(arr, low, mid - 1), find_Max(arr, mid + 1, high))\n    \n    if arr[low] <= arr[mid]:\n        return find_Max(arr, mid + 1, high)\n    \n    return find_Max(arr, low, mid - 1)"
  },
  {
    "id": 351,
    "response": "def extract_column(lst, n):\n    result = []\n    for sublist in lst:\n        if n < len(sublist):\n            result.append(sublist[n])\n        else:\n            result.append(None)\n    return result"
  },
  {
    "id": 352,
    "response": "def Seq_Linear(lst):\n    if len(lst) < 2:\n        return True  # A sequence with less than 2 elements is considered linear\n    \n    # Calculate the difference between the first two elements\n    initial_diff = lst[1] - lst[0]\n    \n    # Check the difference between each pair of consecutive elements\n    for i in range(2, len(lst)):\n        if lst[i] - lst[i - 1] != initial_diff:\n            return False\n    \n    return True"
  },
  {
    "id": 353,
    "response": "def tuple_to_float(tup):\n    # Convert each integer in the tuple to a string\n    str_tuple = tuple(str(num) for num in tup)\n    # Concatenate the string representations\n    concatenated_str = ''.join(str_tuple)\n    # Convert the concatenated string to a float\n    result = float(concatenated_str)\n    return result"
  },
  {
    "id": 354,
    "response": "def find_unique_number(lst):\n    count_dict = {}\n    for num in lst:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    for num, count in count_dict.items():\n        if count == 1:\n            return num"
  },
  {
    "id": 355,
    "response": "def difference(n):\n    sum_of_squares = n * (n + 1) * (2 * n + 1) // 6\n    square_of_sum = (n * (n + 1) // 2) ** 2\n    return square_of_sum - sum_of_squares"
  },
  {
    "id": 356,
    "response": "def find_Odd_Pair(lst, n):\n    for i in range(len(lst)):\n        for j in range(i + 1, len(lst)):\n            if lst[i] ^ lst[j] == n:\n                return (lst[i], lst[j])\n    return None  # Return None if no such pair is found"
  },
  {
    "id": 357,
    "response": "def toggle_string(s):\n    toggled = \"\"\n    for char in s:\n        if char.isupper():\n            toggled += char.lower()\n        elif char.islower():\n            toggled += char.upper()\n        else:\n            toggled += char\n    return toggled"
  },
  {
    "id": 358,
    "response": "def digit_distance_nums(n, n2):\n    # Convert numbers to strings\n    str_n = str(n)\n    str_n2 = str(n2)\n    \n    # Initialize the count of differing digits\n    count = 0\n    \n    # Iterate through the digits of both numbers\n    for i in range(max(len(str_n), len(str_n2))):\n        # Check if the digits at the current position are different\n        if i < len(str_n) and i < len(str_n2) and str_n[i] != str_n2[i]:\n            count += 1\n    \n    return count"
  },
  {
    "id": 359,
    "response": "def max_sub_array_sum(lst, n):\n    max_so_far = float('-inf')\n    max_ending_here = 0\n    \n    for i in range(n):\n        max_ending_here += lst[i]\n        if max_so_far < max_ending_here:\n            max_so_far = max_ending_here\n        if max_ending_here < 0:\n            max_ending_here = 0\n    \n    return max_so_far"
  },
  {
    "id": 360,
    "response": "def union_elements(tup, tup2):\n    # Convert tuples to sets to remove duplicates and perform union\n    set1 = set(tup)\n    set2 = set(tup2)\n    union_set = set1.union(set2)\n    # Convert the set back to a tuple\n    result = tuple(union_set)\n    return result"
  },
  {
    "id": 361,
    "response": "def assign_elements(lst):\n    result = []\n    for i in range(0, len(lst), 2):\n        if i + 1 < len(lst):\n            result.append((lst[i], lst[i + 1]))\n        else:\n            result.append((lst[i], None))\n    return result"
  },
  {
    "id": 362,
    "response": "def Find_Max_Length(lst):\n    max_length = 0\n    for item in lst:\n        if isinstance(item, str) and len(item) > max_length:\n            max_length = len(item)\n    return max_length"
  },
  {
    "id": 363,
    "response": "def extract_values(s):\n    values = []\n    start = 0\n    while True:\n        start = s.find('\"', start)\n        if start == -1:\n            break\n        end = s.find('\"', start + 1)\n        if end == -1:\n            break\n        values.append(s[start + 1:end])\n        start = end + 1\n    return values"
  },
  {
    "id": 364,
    "response": "def count_Pairs(lst, n):\n    count = 0\n    element_count = {}\n    \n    for element in lst:\n        complement = n - element\n        if complement in element_count:\n            count += element_count[complement]\n        if element in element_count:\n            element_count[element] += 1\n        else:\n            element_count[element] = 1\n    \n    return count"
  },
  {
    "id": 365,
    "response": "def split(s):\n    return list(s)"
  },
  {
    "id": 366,
    "response": "def sum_digits(n):\n    # Convert the number to a string to iterate over each digit\n    str_n = str(n)\n    # Initialize the sum to 0\n    total_sum = 0\n    # Iterate over each character in the string representation of the number\n    for char in str_n:\n        # Convert the character back to an integer and add it to the total sum\n        total_sum += int(char)\n    # Return the total sum of the digits\n    return total_sum"
  },
  {
    "id": 367,
    "response": "def issort_list(lst):\n    for i in range(len(lst) - 1):\n        if lst[i] > lst[i + 1]:\n            return False\n    return True"
  },
  {
    "id": 368,
    "response": "def empty_list(n):\n    # Initialize an empty list\n    empty_list = []\n    # Return the empty list\n    return empty_list"
  },
  {
    "id": 369,
    "response": "def sort_sublists(lst):\n    return [sorted(s) for s in lst]"
  },
  {
    "id": 370,
    "response": "def remove_words(lst, lst2):\n    # Create a copy of the list to avoid modifying the original list\n    result = lst[:]\n    # Iterate through each word in the second list\n    for word in lst2:\n        # Remove the word from the result list if it exists\n        while word in result:\n            result.remove(word)\n    return result"
  },
  {
    "id": 371,
    "response": "def max_sum_pair_diff_lessthan_K(lst, n, K):\n    # Sort the array\n    lst.sort()\n    \n    # Initialize two pointers\n    left = 0\n    right = n - 1\n    \n    # Initialize the maximum sum\n    max_sum = -1\n    \n    # Use two-pointer technique to find the pair\n    while left < right:\n        if lst[left] + lst[right] <= K:\n            max_sum = max(max_sum, lst[left] + lst[right])\n            left += 1\n        else:\n            right -= 1\n    \n    return max_sum"
  },
  {
    "id": 372,
    "response": "def two_unique_nums(lst):\n    seen = set()\n    unique_nums = []\n    for num in lst:\n        if num not in seen:\n            seen.add(num)\n            unique_nums.append(num)\n    return unique_nums"
  },
  {
    "id": 373,
    "response": "def unique_product(lst):\n    unique_elements = set(lst)  # Convert list to set to get unique elements\n    product = 1\n    for element in unique_elements:\n        product *= element\n    return product"
  },
  {
    "id": 374,
    "response": "def surfacearea_cylinder(n, n2):\n    radius = n\n    height = n2\n    lateral_surface_area = 2 * math.pi * radius * height\n    base_area = math.pi * radius ** 2\n    total_surface_area = 2 * base_area + lateral_surface_area\n    return total_surface_area"
  },
  {
    "id": 375,
    "response": "def count_no(n, n2, n3, n4):\n    count = 0\n    term = 0\n    while count < n:\n        term += 1\n        if term % n != 0 and term % n2 != 0 and term % n3 != 0 and term % n4 != 0:\n            count += 1\n    return term"
  },
  {
    "id": 376,
    "response": "def is_Sub_Array(lst, lst2, n, n2):\n    if n2 == 0:\n        return True\n    if n < n2:\n        return False\n    for i in range(n):\n        if lst[i] == lst2[0]:\n            j = 1\n            while (j < n2) and (lst[i + j] == lst2[j]):\n                j += 1\n            if j == n2:\n                return True\n    return False"
  },
  {
    "id": 377,
    "response": "def last_digit_factorial(n):\n    if n == 0 or n == 1:\n        return 1\n    elif n == 2:\n        return 2\n    elif n == 3:\n        return 6\n    elif n == 4:\n        return 4\n    else:\n        return 0"
  },
  {
    "id": 378,
    "response": "def interleave_lists(lst1, lst2, lst3):\n    result = []\n    for i in range(len(lst1)):\n        result.append(lst1[i])\n        result.append(lst2[i])\n        result.append(lst3[i])\n    return result"
  },
  {
    "id": 379,
    "response": "def find_dissimilar(tup, tup2):\n    set1 = set(tup)\n    set2 = set(tup2)\n    dissimilar1 = set1 - set2\n    dissimilar2 = set2 - set1\n    return dissimilar1, dissimilar2"
  },
  {
    "id": 380,
    "response": "def extract_even(tup):\n    even_elements = []\n    \n    def is_even(num):\n        return num % 2 == 0\n    \n    def extract_from_tuple(t):\n        for element in t:\n            if isinstance(element, tuple):\n                extract_from_tuple(element)\n            elif is_even(element):\n                even_elements.append(element)\n    \n    extract_from_tuple(tup)\n    return tuple(even_elements)"
  },
  {
    "id": 381,
    "response": "def surface_area(n, n2):\n    # Calculate the area of the base\n    base_area = n * n\n    \n    # Calculate the slant height using the Pythagorean theorem\n    slant_height = ((n2 ** 2) - (n ** 2)) ** 0.5\n    \n    # Calculate the area of one triangular face\n    triangular_face_area = 0.5 * n * slant_height\n    \n    # Calculate the total surface area (base + 4 triangular faces)\n    total_surface_area = base_area + 4 * triangular_face_area\n    \n    return total_surface_area"
  },
  {
    "id": 382,
    "response": "def is_dict_empty(dct):\n    return not bool(dct) or len(dct) == 0"
  },
  {
    "id": 383,
    "response": "def catalan_number(n):\n    if n == 0:\n        return 1\n    numerator = 1\n    for i in range(2, 2*n + 1):\n        numerator *= i\n    denominator = 1\n    for i in range(1, n + 2):\n        denominator *= i\n    for i in range(1, n + 1):\n        denominator *= i\n    return numerator // denominator"
  },
  {
    "id": 384,
    "response": "def find_adverbs(s):\n    adverbs = []\n    for match in re.finditer(r\"\\b\\w+ly\\b\", s):\n        adverbs.append((match.group(), match.start(), match.end()))\n    return adverbs"
  },
  {
    "id": 385,
    "response": "def expensive_items(lst, n):\n    # Sort the list of items based on their values in descending order\n    sorted_items = sorted(lst, key=lambda x: x['value'], reverse=True)\n    # Select the first n items from the sorted list\n    return sorted_items[:n]"
  },
  {
    "id": 386,
    "response": "def split_Arr(lst, n, n2):\n    # Split the array into two parts\n    first_part = lst[:n]\n    second_part = lst[n:n2]\n    \n    # Concatenate the first part to the end of the second part\n    result = second_part + first_part\n    \n    return result"
  },
  {
    "id": 387,
    "response": "def list_tuple(lst):\n    return tuple(lst)"
  },
  {
    "id": 388,
    "response": "def big_diff(lst):\n    if not lst:  # Check if the list is empty\n        return 0\n    max_value = max(lst)\n    min_value = min(lst)\n    return max_value - min_value"
  },
  {
    "id": 389,
    "response": "def perfect_squares(n, n2):\n    # Find the smallest integer whose square is >= n\n    start = int(n**0.5)\n    if start**2 < n:\n        start += 1\n    \n    # Find the largest integer whose square is <= n2\n    end = int(n2**0.5)\n    \n    # Generate all perfect squares between start and end (inclusive)\n    perfect_squares_list = [i**2 for i in range(start, end + 1)]\n    \n    return perfect_squares_list"
  },
  {
    "id": 390,
    "response": "def polar_rect(n, n2):\n    x = n * math.cos(n2)\n    y = n * math.sin(n2)\n    return (x, y)"
  },
  {
    "id": 391,
    "response": "def swap_List(lst):\n    # Check if the list has at least two elements\n    if len(lst) >= 2:\n        # Swap the first and last elements\n        lst[0], lst[-1] = lst[-1], lst[0]\n    return lst"
  },
  {
    "id": 392,
    "response": "def sum_of_product(n):\n    return 2 ** n"
  },
  {
    "id": 393,
    "response": "def removezero_ip(s):\n    # Split the IP address into octets\n    octets = s.split('.')\n    \n    # Strip leading zeros from each octet\n    cleaned_octets = [octet.lstrip('0') for octet in octets]\n    \n    # Join the cleaned octets back into a single string with dots\n    cleaned_ip = '.'.join(cleaned_octets)\n    \n    return cleaned_ip"
  },
  {
    "id": 394,
    "response": "def diff_even_odd(lst):\n    # Find the first even number\n    first_even = next((x for x in lst if x % 2 == 0), None)\n    \n    # Find the first odd number\n    first_odd = next((x for x in lst if x % 2 != 0), None)\n    \n    # Calculate the difference\n    if first_even is not None and first_odd is not None:\n        return first_even - first_odd\n    else:\n        return None  # Return None if there are no even or odd numbers in the list"
  },
  {
    "id": 395,
    "response": "def min_Swaps(s, s2):\n    # Check if the lengths of the strings are the same\n    if len(s) != len(s2):\n        return -1\n    \n    # Count the number of mismatches\n    mismatches = 0\n    for i in range(len(s)):\n        if s[i] != s2[i]:\n            mismatches += 1\n    \n    # If the number of mismatches is odd, it's not possible to make the strings equal\n    if mismatches % 2 != 0:\n        return -1\n    \n    # Calculate the minimum swaps needed\n    swaps = 0\n    i = 0\n    while i < len(s):\n        if s[i] != s2[i]:\n            j = i + 1\n            while j < len(s) and s[j] != s2[i]:\n                j += 1\n            if j == len(s):\n                return -1\n            # Swap the characters\n            s = s[:i] + s[j] + s[i+1:j] + s[i] + s[j+1:]\n            swaps += 1\n        i += 1\n    \n    return swaps"
  },
  {
    "id": 396,
    "response": "def tuple_size(tup):\n    return len(tup)"
  },
  {
    "id": 397,
    "response": "def find_kth(lst, lst2, k):\n    i = j = 0\n    count = 0\n    \n    while i < len(lst) and j < len(lst2):\n        if lst[i] < lst2[j]:\n            count += 1\n            if count == k:\n                return lst[i]\n            i += 1\n        else:\n            count += 1\n            if count == k:\n                return lst2[j]\n            j += 1\n    \n    # If we have exhausted one array, continue with the other\n    while i < len(lst):\n        count += 1\n        if count == k:\n            return lst[i]\n        i += 1\n    \n    while j < len(lst2):\n        count += 1\n        if count == k:\n            return lst2[j]\n        j += 1"
  },
  {
    "id": 398,
    "response": "def armstrong_number(n):\n    # Convert the number to a string to easily iterate over digits\n    digits = str(n)\n    # Calculate the number of digits\n    num_digits = len(digits)\n    # Calculate the sum of each digit raised to the power of the number of digits\n    sum_of_powers = sum(int(digit) ** num_digits for digit in digits)\n    # Check if the sum of powers is equal to the original number\n    return sum_of_powers == n"
  },
  {
    "id": 399,
    "response": "def sum_average(n):\n    if n <= 0:\n        return (0, 0)\n    sum_n = n * (n + 1) // 2\n    average = sum_n / n\n    return (sum_n, average)"
  },
  {
    "id": 400,
    "response": "def is_Even(n):\n    return (n & 1) == 0"
  }
]