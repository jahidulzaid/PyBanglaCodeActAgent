[
  {
    "id": 1,
    "response": "def max_chain_length(lst, n):\n    if n == 0:\n        return 0\n    # Sort the list based on the end value of each pair\n    lst.sort(key=lambda x: x[1])\n    current_end = -float('inf')\n    chain_length = 0\n    for i in range(n):\n        if lst[i][0] > current_end:\n            current_end = lst[i][1]\n            chain_length += 1\n    return chain_length"
  },
  {
    "id": 2,
    "response": "def first_repeated_char(s):\n    seen = {}\n    for char in s:\n        if char in seen:\n            return char\n        seen[char] = 1\n    return None"
  },
  {
    "id": 3,
    "response": "def get_ludic(n):\n    if n < 1:\n        return []\n    ludics = list(range(1, n+1))\n    index = 1\n    while index < len(ludics):\n        # The next Ludic number is ludics[index]\n        # Remove every (ludics[index])th element starting from index\n        # Wait, the algorithm is a bit more involved. Let me look up the correct method."
  },
  {
    "id": 4,
    "response": "def reverse_words(s):\n    words = s.split()\n    reversed_words = [word[::-1] for word in words]\n    return ' '.join(reversed_words)"
  },
  {
    "id": 5,
    "response": "def prime_num(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True"
  },
  {
    "id": 6,
    "response": "def radian_degree(n):\n    return n * math.pi / 180.0"
  },
  {
    "id": 7,
    "response": "def find_literals(s, s2):\n    pattern = re.escape(s2)\n    match = re.search(pattern, s)\n    if match:\n        return match.start()\n    else:\n        return -1"
  },
  {
    "id": 8,
    "response": "def bell_number(n):\n    if n == 0:\n        return 1\n    # Initialize the Bell triangle with the first row\n    bell_triangle = [[1]]  # Bell(1) is 1\n    for i in range(1, n):\n        # The first element of row i+1 is the last element of row i\n        current_row = [bell_triangle[i][-1]]\n        for j in range(1, i + 1):\n            current_row.append(current_row[j - 1] + bell_triangle[i][j - 1])\n        bell_triangle.append(current_row)\n    return bell_triangle[n - 1][0]"
  },
  {
    "id": 9,
    "response": "def floor_Min(*args):"
  },
  {
    "id": 10,
    "response": "def remove_kth_element(lst, n):\n    # remove the nth element (1-based)\n    # so index is n-1\n    lst.pop(n-1)\n    return lst"
  },
  {
    "id": 11,
    "response": "def max_of_nth(lst, n):\n    return max(t[n] for t in lst)"
  },
  {
    "id": 12,
    "response": "def merge(lst):\n    if len(lst) < 2:\n        return lst  # Or raise an error?\n    combined = lst[0] + lst[-1]\n    return [combined] + lst[1:-1]"
  },
  {
    "id": 13,
    "response": "def maximum_value(lst):\n    if not lst:\n        return None\n    max_val = lst[0]\n    for item in lst:\n        if item > max_val:\n            max_val = item\n    return max_val"
  },
  {
    "id": 14,
    "response": "def cummulative_sum(lst):\n    cumulative_total = 0\n    result = []\n    for t in lst:\n        cumulative_total += sum(t)\n        result.append(cumulative_total)\n    return result"
  },
  {
    "id": 15,
    "response": "def average_tuple(tup):\n    return sum(tup) / len(tup)"
  },
  {
    "id": 16,
    "response": "def tuple_modulo(tup, tup2):\n    if len(tup) != len(tup2):\n        raise ValueError(\"Tuples must be of the same length\")\n    result = []\n    for a, b in zip(tup, tup2):\n        if b == 0:\n            raise ValueError(\"Division by zero is not allowed\")\n        result.append(a % b)\n    return tuple(result)"
  },
  {
    "id": 17,
    "response": "def min_Jumps(d, n, n2, n3):\n    from collections import deque\n    visited = set()\n    queue = deque()\n    queue.append((0, 0))  # (current position, jumps)\n    visited.add(0)\n    while queue:\n        pos, jumps = queue.popleft()\n        if pos == d:\n            return jumps\n        for step in [n, n2, n3]:\n            new_pos = pos + step\n            if new_pos == d:\n                return jumps + 1\n            elif new_pos < d and new_pos not in visited:\n                visited.add(new_pos)\n                queue.append((new_pos, jumps + 1))\n    return -1  # if not possible"
  },
  {
    "id": 18,
    "response": "def div_list(lst, lst2):\n    return list(map(lambda x, y: y / x, lst, lst2))"
  },
  {
    "id": 19,
    "response": "def move_num(s):\n    digits = []\n    non_digits = []\n    for char in s:\n        if char.isdigit():\n            digits.append(char)\n        else:\n            non_digits.append(char)\n    return ''.join(digits + non_digits)"
  },
  {
    "id": 20,
    "response": "def largest_subset(lst, n):\n    count = 0\n    for num in lst:\n        if num % n == 0:\n            count +=1\n    return count"
  },
  {
    "id": 21,
    "response": "def increment_numerics(lst, n):\n    result = []\n    for s in lst:\n        # Process each string\n        new_s = re.sub(r'(\\d+)', lambda m: str(int(m.group(1)) + n), s)\n        result.append(new_s)\n    return result"
  },
  {
    "id": 22,
    "response": "def get_median(lst, lst2, n):\n    merged = []\n    i = j = 0\n    while i < n and j < n:\n        if lst[i] <= lst2[j]:\n            merged.append(lst[i])\n            i += 1\n        else:\n            merged.append(lst2[j])\n            j += 1\n    # Add remaining elements\n    merged.extend(lst[i:])\n    merged.extend(lst2[j:])\n    # Calculate median\n    mid = n - 1\n    return (merged[mid] + merged[mid + 1]) / 2"
  },
  {
    "id": 23,
    "response": "def nth_nums(lst, n):\n    return list(map(lambda x: x**n, lst))"
  },
  {
    "id": 24,
    "response": "def is_upper(s):\n    return s.upper()"
  },
  {
    "id": 25,
    "response": "def swap_List(lst):\n    if len(lst) < 2:\n        return lst\n    lst[0], lst[-1] = lst[-1], lst[0]\n    return lst"
  },
  {
    "id": 26,
    "response": "def triangle_area(n):\n    return (n ** 2) / 4"
  },
  {
    "id": 27,
    "response": "def find_First_Missing(lst):\n    # implementation"
  },
  {
    "id": 28,
    "response": "def replace_spaces(s):\n    return s.replace(' ', '%20')"
  },
  {
    "id": 29,
    "response": "def Split(lst):\n    return [x for x in lst if isinstance(x, int) and x % 2 == 0]"
  },
  {
    "id": 30,
    "response": "def get_coordinates(tup):\n    result = []\n    for i in range(len(tup) - 1):\n        result.append( (tup[i], tup[i+1]) )\n    return result"
  },
  {
    "id": 31,
    "response": "def replace_spaces(s):\n    return re.sub(r'\\s', '_', s)"
  },
  {
    "id": 32,
    "response": "def move_zero(lst):\n    # create a new list with non-zero elements\n    non_zeros = [x for x in lst if x != 0]\n    # count the number of zeros\n    zero_count = len(lst) - len(non_zeros)\n    # return non_zeros + [0]*zero_count\n    return non_zeros + [0]*zero_count"
  },
  {
    "id": 33,
    "response": "def pair_OR_Sum(lst, n):\n    total = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            total += lst[i] ^ lst[j]\n    return total"
  },
  {
    "id": 34,
    "response": "def even_Power_Sum(n):\n    total = 0\n    for i in range(1, n+1):\n        total += (2*i)**4\n    return total"
  },
  {
    "id": 35,
    "response": "def heapify(lst, n, i):\n    largest = i  # Initialize largest as root\n    left = 2 * i + 1\n    right = 2 * i + 2"
  },
  {
    "id": 36,
    "response": "def Check_Solution(a, b, c):\n    discriminant = b**2 - 4*a*c\n    return discriminant > 0"
  },
  {
    "id": 37,
    "response": "def noprofit_noloss(n, n2):\n    return n == n2"
  },
  {
    "id": 38,
    "response": "def wind_chill(n, n2):\n    # Check if wind speed is less than 3 mph\n    if n2 < 3:\n        return n\n    # Calculate wind chill using the formula\n    v_pow = n2 ** 0.16\n    wind_chill = 35.74 + 0.6215 * n - 35.75 * v_pow + 0.4275 * n * v_pow\n    return wind_chill"
  },
  {
    "id": 39,
    "response": "def sample_nam(lst):\n    total = 0\n    for name in lst:\n        if name and name[0].islower():\n            total += len(name)\n    return total"
  },
  {
    "id": 40,
    "response": "def remove_parenthesis(lst):\n    return [s.replace('(', '').replace(')', '') for s in lst]"
  },
  {
    "id": 41,
    "response": "def is_nonagonal(n):\n    if n <= 0:\n        return False\n    discriminant = 1 + 56 * n\n    sqrt_discriminant = math.isqrt(discriminant)\n    if sqrt_discriminant * sqrt_discriminant != discriminant:\n        return False\n    k = (5 + sqrt_discriminant) / 14\n    return k.is_integer() and k > 0"
  },
  {
    "id": 42,
    "response": "def remove_similar_row(lst):\n    seen = set()\n    result = []\n    for row in lst:\n        if row not in seen:\n            seen.add(row)\n            result.append(row)\n    return result"
  },
  {
    "id": 43,
    "response": "def text_match_wordz_middle(s):\n    if len(s) < 3:\n        return False\n    for i in range(1, len(s)-1):\n        if s[i] == 'z':\n            return True\n    return False"
  },
  {
    "id": 44,
    "response": "def reverse_Array_Upto_K(lst, n):\n    part1 = lst[:n]\n    part1_reversed = part1[::-1]\n    return part1_reversed + lst[n:]"
  },
  {
    "id": 45,
    "response": "def find_k_product(lst, n):\n    product = 1\n    for t in lst:\n        product *= t[n]\n    return product"
  },
  {
    "id": 46,
    "response": "def No_of_cubes(n, n2):\n    if n2 == 0:\n        return 0\n    return (n // n2) ** 3"
  },
  {
    "id": 47,
    "response": "def split_upperstring(s):\n    result = []\n    start = 0\n    for i, char in enumerate(s):\n        if char.isupper():\n            result.append(s[start:i])\n            start = i\n    result.append(s[start:])\n    return result"
  },
  {
    "id": 48,
    "response": "def exchange_elements(lst):\n    for i in range(0, len(lst)-1, 2):\n        lst[i], lst[i+1] = lst[i+1], lst[i]\n    return lst"
  },
  {
    "id": 49,
    "response": "def sum_Range_list(lst, n, n2):\n    start = min(n, n2)\n    end = max(n, n2)\n    # adjust start and end to be within the list's indices\n    start = max(0, start)\n    end = min(len(lst)-1, end)\n    if start > end:\n        return 0\n    return sum(lst[start:end+1])"
  },
  {
    "id": 50,
    "response": "def are_Equal(lst, lst2, n, n2):\n    if n != n2:\n        return False\n    for i in range(n):\n        if lst[i] != lst2[i]:\n            return False\n    return True"
  },
  {
    "id": 51,
    "response": "def check_subset(tup, tup2):\n    return set(tup).issubset(set(tup2))"
  },
  {
    "id": 52,
    "response": "def matrix_to_list(lst):\n    return list(zip(*lst))"
  },
  {
    "id": 53,
    "response": "def grouping_dictionary(lst):\n    result = {}\n    for index, element in enumerate(lst):\n        if element not in result:\n            result[element] = []\n        result[element].append(index)\n    return result"
  },
  {
    "id": 54,
    "response": "def rectangle_perimeter(n, n2):\n    return 2 * (n + n2)"
  },
  {
    "id": 55,
    "response": "def fifth_Power_Sum(n):\n    total = 0\n    for i in range(1, n+1):\n        total += i**5\n    return total"
  },
  {
    "id": 56,
    "response": "def find_Min_Sum(lst, lst2, n):\n    # Sort both lists to minimize the absolute differences\n    lst.sort()\n    lst2.sort()\n    # Calculate the sum of absolute differences\n    total = 0\n    for i in range(n):\n        total += abs(lst[i] - lst2[i])\n    return total"
  },
  {
    "id": 57,
    "response": "def first_Digit(n):\n    if n == 0:\n        return 1\n    log_sum = 0.0\n    for i in range(1, n+1):\n        log_sum += math.log10(i)\n    fractional_part = log_sum - int(log_sum)\n    first_digit = 10 ** fractional_part\n    # Handle cases where the first digit is very close to an integer due to precision\n    if first_digit >= 10:\n        first_digit = int(first_digit)\n    else:\n        first_digit = int(first_digit)\n    return first_digit"
  },
  {
    "id": 58,
    "response": "def max_occurrences(lst):\n    if not lst:\n        return None\n    counts = Counter()\n    for item in lst:\n        counts[item] += 1\n    max_count = -1\n    result = None\n    for item in lst:\n        if counts[item] > max_count:\n            max_count = counts[item]\n            result = item\n        elif counts[item] == max_count and result is None:\n            result = item\n    return result"
  },
  {
    "id": 59,
    "response": "def Repeat(lst):\n    seen = set()\n    duplicates = set()\n    for num in lst:\n        if num in seen:\n            duplicates.add(num)\n        else:\n            seen.add(num)\n    for dup in duplicates:\n        print(dup)"
  },
  {
    "id": 60,
    "response": "def find_Points(n, n2, n3, n4):\n    # Check if the two ranges [n, n2] and [n3, n4] do not overlap\n    # Assume that n <= n2 and n3 <= n4\n    return (n2 < n3) or (n4 < n)"
  },
  {
    "id": 61,
    "response": "def max_sum_of_three_consecutive(lst, n):\n    max_sum = 0\n    for i in range(n - 2):\n        current_sum = lst[i] + lst[i+1] + lst[i+2]\n        if current_sum > max_sum:\n            max_sum = current_sum\n    return max_sum"
  },
  {
    "id": 62,
    "response": "def sorted_dict(dct):\n    return sorted(dct.items())"
  },
  {
    "id": 63,
    "response": "def find_max_val(n, n2, n3):\n    if n2 >= n or n3 < n2:\n        return -1\n    max_m = (n3 - n2) // n\n    if max_m < 0:\n        return -1\n    return max_m * n + n2"
  },
  {
    "id": 64,
    "response": "def average_Even(n):\n    if n < 2:\n        return 0  # or raise an error?\n    k = n // 2\n    return (k + 1)"
  },
  {
    "id": 65,
    "response": "def move_last(lst):\n    if not lst:\n        return lst\n    return [lst[-1]] + lst[:-1]"
  },
  {
    "id": 66,
    "response": "def count_char(s, s2):\n    counts = {}\n    for char in s2:\n        counts[char] = s.count(char)\n    return counts"
  },
  {
    "id": 67,
    "response": "def count_vowels(s):\n    vowels = 'aeiouAEIOU'\n    count = 0\n    for char in s:\n        if char in vowels:\n            count +=1\n    return count"
  },
  {
    "id": 68,
    "response": "def replace(s, s2):\n    if s2 in s:\n        return s2\n    else:\n        return s"
  },
  {
    "id": 69,
    "response": "def check_IP(s):\n    pattern = r'^(\\d{1,3}\\.){3}\\d{1,3}$'\n    if re.match(pattern, s):\n        parts = s.split('.')\n        for part in parts:\n            if not (0 <= int(part) <= 255):\n                return False\n            if len(part) > 1 and part[0] == '0':\n                return False\n        return True\n    return False"
  },
  {
    "id": 70,
    "response": "def decreasing_trend(lst):\n    if len(lst) <= 1:\n        return True\n    for i in range(len(lst) - 1):\n        if lst[i] <= lst[i+1]:\n            return False\n    return True"
  },
  {
    "id": 71,
    "response": "def find_rightmost_0(n):\n    i = 0\n    while (n & (1 << i)) != 0:\n        i += 1\n    return i"
  },
  {
    "id": 72,
    "response": "def max_of_three(n, n2, n3):\n    return max(n, n2, n3)"
  },
  {
    "id": 73,
    "response": "def convert(lst):\n    return int(''.join(map(str, lst)))"
  },
  {
    "id": 74,
    "response": "def remove_duplicate(s):\n    words = s.split()\n    seen = set()\n    result = []\n    for word in words:\n        if word not in seen:\n            seen.add(word)\n            result.append(word)\n    return ' '.join(result)"
  },
  {
    "id": 75,
    "response": "def sum_nums(n1, n2, lower, upper):\n    total = n1 + n2\n    if lower <= total <= upper:\n        return 20\n    else:\n        return total"
  },
  {
    "id": 76,
    "response": "def remove_extra_char(s):\n    return re.sub(r'[^a-zA-Z0-9]', '', s)"
  },
  {
    "id": 77,
    "response": "def validity_triangle(n, n2, n3):\n    # Check if any side is non-positive\n    if n <= 0 or n2 <= 0 or n3 <= 0:\n        return False\n    \n    # Sort the sides to apply the triangle inequality theorem\n    sides = sorted([n, n2, n3])\n    a, b, c = sides\n    \n    # Check if the sum of the two smaller sides is greater than the largest side\n    return a + b > c"
  },
  {
    "id": 78,
    "response": "def remove_spaces(s):\n    return s.replace(' ', '')"
  },
  {
    "id": 79,
    "response": "def access_key(dct, n):\n    return dct.get(n)"
  },
  {
    "id": 80,
    "response": "def increasing_trend(lst):\n    for i in range(len(lst) - 1):\n        if lst[i] >= lst[i + 1]:\n            return False\n    return True"
  },
  {
    "id": 81,
    "response": "def smallest_Divisor(n):\n    if n % 2 == 0:\n        return 2\n    max_divisor = int(n**0.5) + 1\n    for i in range(3, max_divisor, 2):\n        if n % i == 0:\n            return i\n    return n"
  },
  {
    "id": 82,
    "response": "def mul_list(lst, lst2):\n    if len(lst) != len(lst2):\n        raise ValueError(\"Both lists must have the same length.\")\n    return list(map(lambda x, y: x * y, lst, lst2))"
  },
  {
    "id": 83,
    "response": "def sum_square(n):\n    if n < 0:\n        return False\n    max_a = int(n**0.5)\n    for a in range(max_a + 1):\n        b_squared = n - a*a\n        if b_squared < 0:\n            continue\n        b = int(b_squared**0.5)\n        if b*b == b_squared:\n            return True\n    return False"
  },
  {
    "id": 84,
    "response": "def count_Char(s, s2):\n    counts = {}\n    for char in s2:\n        counts[char] = s.count(char)\n    return counts"
  },
  {
    "id": 85,
    "response": "def sum_Of_Primes(n):\n    if n < 2:\n        return 0\n    total = 0\n    for i in range(2, n + 1):\n        is_prime = True\n        for j in range(2, int(i**0.5) + 1):\n            if i % j == 0:\n                is_prime = False\n                break\n        if is_prime:\n            total += i\n    return total"
  },
  {
    "id": 86,
    "response": "def freq_element(tup):\n    return dict(Counter(tup))"
  },
  {
    "id": 87,
    "response": "def recur_gcd(n, n2):\n    if n2 == 0:\n        return n\n    else:\n        return recur_gcd(n2, n % n2)"
  },
  {
    "id": 88,
    "response": "def len_complex(n, n2):\n    return math.sqrt(n**2 + n2**2)"
  },
  {
    "id": 89,
    "response": "def min_jumps(lst, n):\n    if n == 1:\n        return 0\n    jumps = 0\n    current_end = 0\n    farthest = 0\n    for i in range(n):\n        farthest = max(farthest, i + lst[i])\n        if i == current_end:\n            jumps +=1\n            current_end = farthest\n            if current_end >= n-1:\n                break\n    return jumps"
  },
  {
    "id": 90,
    "response": "def mul_consecutive_nums(lst):\n    product = 1\n    for num in lst:\n        product *= num\n    return product"
  },
  {
    "id": 91,
    "response": "def group_element(lst):\n    groups = {}\n    for item in lst:\n        key = item[1]\n        value = item[0]\n        if key not in groups:\n            groups[key] = []\n        groups[key].append(value)\n    return groups"
  },
  {
    "id": 92,
    "response": "def last_Two_Digits(n):\n    if n >= 10:\n        return '00'\n    result = 1\n    for i in range(1, n + 1):\n        result *= i\n    return f\"{result % 100:02d}\""
  },
  {
    "id": 93,
    "response": "def remove_multiple_spaces(s):\n    return re.sub(' +', ' ', s)"
  },
  {
    "id": 94,
    "response": "def extract_unique(dct):\n    return list(set(dct.values()))"
  },
  {
    "id": 95,
    "response": "def check_greater(tup, tup2):\n    if len(tup) != len(tup2):\n        return False\n    for a, b in zip(tup, tup2):\n        if not (b > a):\n            return False\n    return True"
  },
  {
    "id": 96,
    "response": "def zip_list(lst, lst2):\n    return list(zip(lst, lst2))"
  },
  {
    "id": 97,
    "response": "def count_even(lst):\n    return len(list(filter(lambda x: x % 2 == 0, lst)))"
  },
  {
    "id": 98,
    "response": "def sort_dict_item(dct):\n    # For each key in the dictionary, compute the product of its elements\n    # Then sort the items based on that product\n    # Return the sorted list of items"
  },
  {
    "id": 99,
    "response": "def min_swaps(s, s2):\n    if len(s) != len(s2):\n        return -1\n    count_0_s = s.count('0')\n    count_1_s = len(s) - count_0_s\n    count_0_s2 = s2.count('0')\n    count_1_s2 = len(s2) - count_0_s2\n    if count_0_s != count_0_s2 or count_1_s != count_1_s2:\n        return -1\n    a = 0\n    for i in range(len(s)):\n        if s[i] == '0' and s2[i] == '1':\n            a += 1\n    return a"
  },
  {
    "id": 100,
    "response": "def count_range_in_list(lst, n, n2):\n    count = 0\n    for num in lst:\n        if n <= num <= n2:\n            count += 1\n    return count"
  },
  {
    "id": 101,
    "response": "def equilibrium_index(lst):\n    total_sum = sum(lst)\n    left_sum = 0\n    for i in range(len(lst)):\n        right_sum = total_sum - left_sum - lst[i]\n        if left_sum == right_sum:\n            return i\n        left_sum += lst[i]\n    return -1"
  },
  {
    "id": 102,
    "response": "def removals(lst, n, n2):\n    count = 0\n    for num in lst:\n        if num < n or num > n2:\n            count +=1\n    return count"
  },
  {
    "id": 103,
    "response": "def is_key_present(dct, n):\n    return n in dct"
  },
  {
    "id": 104,
    "response": "def harmonic_sum(n):\n    if n <= 0:\n        return 0.0\n    total = 0.0\n    for i in range(1, n + 1):\n        total += 1.0 / i\n    return total"
  },
  {
    "id": 105,
    "response": "def sort_sublists(lst):\n    return sorted(lst, key=lambda x: (len(x), x))"
  },
  {
    "id": 106,
    "response": "def is_subset(lst, n, lst2, n2):\n    for i in range(n):\n        if lst[i] not in lst2:\n            return False\n    return True"
  },
  {
    "id": 107,
    "response": "def count_Set_Bits(n):\n    total = 0\n    for i in range(1, n + 1):\n        total += bin(i).count('1')\n    return total"
  },
  {
    "id": 108,
    "response": "def Convert(s):\n    return list(s)"
  },
  {
    "id": 109,
    "response": "def get_unique(lst):\n    return len(set(lst))"
  },
  {
    "id": 110,
    "response": "def front_and_rear(tup):\n    if not tup:\n        return ()\n    return (tup[0], tup[-1])"
  },
  {
    "id": 111,
    "response": "def product_Equal(n):\n    digits = list(str(n))  # Convert to string to get each digit\n    # Check if product is even\n    has_even = any(int(d) % 2 == 0 for d in digits)\n    # Check for duplicates\n    has_duplicates = len(set(digits)) < len(digits)\n    return has_even and has_duplicates"
  },
  {
    "id": 112,
    "response": "def remove_duplicate(lst):\n    seen = set()\n    result = []\n    for item in lst:\n        if item not in seen:\n            seen.add(item)\n            result.append(item)\n    return result"
  },
  {
    "id": 113,
    "response": "def check_valid(tup):\n    for element in tup:\n        if not isinstance(element, int):\n            return False\n    return True"
  },
  {
    "id": 114,
    "response": "def count_Fac(n):\n    if n <= 1:\n        return 0\n    factors = set()\n    # Handle 2 separately\n    if n % 2 == 0:\n        factors.add(2)\n        while n % 2 == 0:\n            n = n // 2\n    # Now check odd numbers starting from 3\n    i = 3\n    while i*i <= n:\n        if n % i == 0:\n            factors.add(i)\n            while n % i == 0:\n                n = n // i\n        i += 2\n    # If remaining n is a prime\n    if n > 1:\n        factors.add(n)\n    return len(factors)"
  },
  {
    "id": 115,
    "response": "def str_to_tuple(s):\n    return tuple(int(num.strip()) for num in s.split(','))"
  },
  {
    "id": 116,
    "response": "def rombus_perimeter(n):\n    return 4 * n"
  },
  {
    "id": 117,
    "response": "def sd_calc(lst):\n    if not lst:\n        return 0\n    mean = sum(lst) / len(lst)\n    squared_diffs = [(x - mean)**2 for x in lst]\n    variance = sum(squared_diffs) / len(lst)\n    return math.sqrt(variance)"
  },
  {
    "id": 118,
    "response": "def alternate_elements(lst):\n    return lst[::2]"
  },
  {
    "id": 119,
    "response": "def text_match(s):\n    return bool(re.search(r'ab*', s))"
  },
  {
    "id": 120,
    "response": "def add_dict_to_tuple(tup, dct):\n    return tuple(list(tup) + [dct])"
  },
  {
    "id": 121,
    "response": "def maxAverageOfPath(lst, n):\n    # Initialize dp\n    dp = [[0]*n for _ in range(n)]\n    dp[0][0] = lst[0][0]\n    for j in range(1, n):\n        dp[0][j] = dp[0][j-1] + lst[0][j]\n    for i in range(1, n):\n        dp[i][0] = dp[i-1][0] + lst[i][0]\n    for i in range(1, n):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + lst[i][j]\n    return dp[n-1][n-1] / (2*n - 1)"
  },
  {
    "id": 122,
    "response": "def filter_data(dct, n, n2):\n    filtered = {}\n    for student_id, student_data in dct.items():\n        if student_data['height'] >= n and student_data['width'] >= n2:\n            filtered[student_id] = student_data\n    return filtered"
  },
  {
    "id": 123,
    "response": "def count_same_pair(lst, lst2):\n    count = 0\n    for i in range(min(len(lst), len(lst2))):\n        if lst[i] == lst2[i]:\n            count += 1\n    return count"
  },
  {
    "id": 124,
    "response": "def power_base_sum(n, n2):\n    # compute the power\n    power_result = n ** n2\n    # convert to string and sum digits\n    return sum(int(digit) for digit in str(power_result))"
  },
  {
    "id": 125,
    "response": "def extract_quotation(s):\n    # Use regular expression to find all quoted strings\n    matches = re.findall(r'[\"\\']([^\"\\']*)[\"\\']', s)\n    return matches"
  },
  {
    "id": 126,
    "response": "def multiply_elements(tup):\n    result = 1\n    for num in tup:\n        result *= num\n    return result"
  },
  {
    "id": 127,
    "response": "def remove_char(s):\n    return re.sub(r'[^a-zA-Z0-9]', '', s)"
  },
  {
    "id": 128,
    "response": "def sum_list(lst, lst2):\n    if len(lst) != len(lst2):\n        raise ValueError(\"Both lists must have the same length.\")\n    result = []\n    for i in range(len(lst)):\n        result.append(lst[i] + lst2[i])\n    return result"
  },
  {
    "id": 129,
    "response": "def add_list(lst, lst2):\n    return list(map(lambda x, y: x + y, lst, lst2))"
  },
  {
    "id": 130,
    "response": "def consecutive_duplicates(lst):\n    if not lst:\n        return []\n    result = [lst[0]]\n    for item in lst[1:]:\n        if item != result[-1]:\n            result.append(item)\n    return result"
  },
  {
    "id": 131,
    "response": "def lateralsurface_cone(n, n2):\n    return math.pi * n * n2"
  },
  {
    "id": 132,
    "response": "def replace_specialchar(s):\n    return ''.join([':' if c in ' ,.' else c for c in s])"
  },
  {
    "id": 133,
    "response": "def find_first_occurrence(lst, n):\n    for i in range(len(lst)):\n        if lst[i] == n:\n            return i\n    return -1"
  },
  {
    "id": 134,
    "response": "def sum_Of_Subarray_Prod(lst, n):\n    total = 0\n    for i in range(len(lst) - n + 1):\n        product = 1\n        for j in range(i, i + n):\n            product *= lst[j]\n        total += product\n    return total"
  },
  {
    "id": 135,
    "response": "def toggle_middle_bits(n):\n    m = n.bit_length()\n    if m <= 1:\n        return n\n    mask = ( (1 << (m-2)) -1 ) << 1\n    return n ^ mask"
  },
  {
    "id": 136,
    "response": "def left_insertion(lst, n):\n    for i in range(len(lst)):\n        if lst[i] >= n:\n            return i\n    return len(lst)"
  },
  {
    "id": 137,
    "response": "def check_str(s):\n    if not s:\n        return False\n    first_char = s[0]\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    if first_char.isalpha():\n        return first_char.lower() in vowels\n    return False"
  },
  {
    "id": 138,
    "response": "def geometric_sum(n):\n    if n == 0:\n        return 0\n    return 2 ** (n - 1) - 1"
  },
  {
    "id": 139,
    "response": "def find_Index(n):\n    k = 1\n    while True:\n        t = k * (k + 1) // 2\n        if len(str(t)) == n:\n            return k\n        k += 1"
  },
  {
    "id": 140,
    "response": "def tuple_to_dict(tup):\n    d = {}\n    for i in range(0, len(tup), 2):\n        if i + 1 < len(tup):\n            d[tup[i]] = tup[i+1]\n    return d"
  },
  {
    "id": 141,
    "response": "def all_Characters_Same(s):\n    if not s:\n        return True\n    first_char = s[0]\n    for char in s:\n        if char != first_char:\n            return False\n    return True"
  },
  {
    "id": 142,
    "response": "def area_tetrahedron(n):\n    return math.sqrt(3) * n ** 2"
  },
  {
    "id": 143,
    "response": "def rotate_right(lst, n, n2):\n    # first rotation by n\n    lst = lst[-n:] + lst[:-n]\n    # second rotation by n2\n    lst = lst[-n2:] + lst[:-n2]\n    return lst"
  },
  {
    "id": 144,
    "response": "def check_none(tup):\n    return any(element is None for element in tup)"
  },
  {
    "id": 145,
    "response": "def divisible_by_digits(n, n2):"
  },
  {
    "id": 146,
    "response": "def sector_area(n, n2):\n    # Assuming n is the radius and n2 is the central angle in radians\n    return (n2 * n * n) / 2"
  },
  {
    "id": 147,
    "response": "def lcs_of_three(s, s2, s3, n, n2, n3):"
  },
  {
    "id": 148,
    "response": "def capital_words_spaces(s):\n    if not s:\n        return \"\"\n    result = [s[0]]\n    for char in s[1:]:\n        if char.isupper():\n            result.append(' ')\n            result.append(char)\n        else:\n            result.append(char)\n    return ''.join(result)"
  },
  {
    "id": 149,
    "response": "def sort_numeric_strings(lst):\n    return sorted(lst, key=lambda x: float(x))"
  },
  {
    "id": 150,
    "response": "def add_tuple(lst, tup):\n    return lst + list(tup)"
  },
  {
    "id": 151,
    "response": "def check_min_heap(lst, n):\n    for i in range(n):\n        left = 2 * i + 1\n        right = 2 * i + 2\n        if left < n and lst[i] > lst[left]:\n            return False\n        if right < n and lst[i] > lst[right]:\n            return False\n    return True"
  },
  {
    "id": 152,
    "response": "def jacobsthal_num(n):\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    a, b = 0, 1\n    for _ in range(2, n+1):\n        c = b + 2*a\n        a, b = b, c\n    return b"
  },
  {
    "id": 153,
    "response": "def min_k(lst, n):\n    # Sort the list of tuples based on the first element\n    sorted_lst = sorted(lst, key=lambda x: x[0])\n    # Take the first n elements\n    return sorted_lst[:n]"
  },
  {
    "id": 154,
    "response": "def extract_index_list(lst, lst2, lst3):\n    result = []\n    min_len = min(len(lst), len(lst2), len(lst3))\n    for i in range(min_len):\n        if lst[i] == lst2[i] == lst3[i]:\n            result.append(i)\n    return result"
  },
  {
    "id": 155,
    "response": "def second_smallest(lst):\n    if len(lst) < 2:\n        raise ValueError(\"List must contain at least two elements.\")\n    sorted_lst = sorted(lst)\n    return sorted_lst[1]"
  },
  {
    "id": 156,
    "response": "def text_match_zero_one(s):\n    return '0' in s or 'b' in s"
  },
  {
    "id": 157,
    "response": "def count_reverse_pairs(lst):\n    count = 0\n    n = len(lst)\n    for i in range(n):\n        for j in range(i+1, n):\n            if lst[i] == lst[j][::-1]:\n                count +=1\n    return count"
  },
  {
    "id": 158,
    "response": "def unique_sublists(lst):\n    unique = set()\n    n = len(lst)\n    for i in range(n):\n        for j in range(i, n):\n            sub = tuple(lst[i:j+1])\n            unique.add(sub)\n    return len(unique)"
  },
  {
    "id": 159,
    "response": "def is_decimal(s):\n    pattern = r'^[-+]?(\\d+\\.\\d{2}|\\.\\d{2})$'\n    return bool(re.match(pattern, s))"
  },
  {
    "id": 160,
    "response": "def unique_Element(lst, n):\n    if n == 0:\n        return False  # or handle empty list as per problem's requirement\n    first = lst[0]\n    for i in range(1, n):\n        if lst[i] != first:\n            return False\n    return True"
  },
  {
    "id": 161,
    "response": "def arc_length(n, n2): ..."
  },
  {
    "id": 162,
    "response": "def check_monthnumber_number(n):\n    if n < 1 or n > 12:\n        return False\n    return n in {4, 6, 9, 11}"
  },
  {
    "id": 163,
    "response": "def find_Min_Diff(tup, n):\n    if n < 2:\n        return 0\n    sorted_tup = sorted(tup)\n    min_diff = float('inf')\n    for i in range(n - 1):\n        diff = abs(sorted_tup[i] - sorted_tup[i + 1])\n        if diff < min_diff:\n            min_diff = diff\n    return min_diff"
  },
  {
    "id": 164,
    "response": "def number_ctr(s):\n    count = 0\n    for char in s:\n        if char.isdigit():\n            count += 1\n    return count"
  },
  {
    "id": 165,
    "response": "def is_polite(n):\n    if n <= 0:\n        return False\n    return not (n & (n - 1)) == 0"
  },
  {
    "id": 166,
    "response": "def pair_wise(lst):\n    result = []\n    for i in range(len(lst) - 1):\n        result.append( (lst[i], lst[i+1]) )\n    return result"
  },
  {
    "id": 167,
    "response": "def get_Pairs_Count(lst, n, n2):\n    target = n + n2\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if lst[i] + lst[j] == target:\n                count +=1\n    return count"
  },
  {
    "id": 168,
    "response": "def check_Odd_Parity(n):\n    return n % 2 == 1"
  },
  {
    "id": 169,
    "response": "def Diff(lst, lst2):\n    return [x for x in lst if x not in lst2]"
  },
  {
    "id": 170,
    "response": "def odd_Num_Sum(n):\n    total = 0\n    for k in range(1, n + 1):\n        odd_number = 2 * k - 1\n        total += odd_number ** 4\n    return total"
  },
  {
    "id": 171,
    "response": "def check_expression(s):\n    stack = []\n    brackets = {'(': ')', '[': ']', '{': '}'}\n    for char in s:\n        if char in brackets:\n            stack.append(char)\n        elif char in brackets.values():\n            if not stack:\n                return False\n            top = stack.pop()\n            if brackets.get(top) != char:\n                return False\n    return not stack"
  },
  {
    "id": 172,
    "response": "def remove_length(s, n):\n    words = s.split()\n    filtered = [word for word in words if len(word) != n]\n    return ' '.join(filtered)"
  },
  {
    "id": 173,
    "response": "def occurance_substring(s, s2):\n    result = []\n    start = 0\n    while True:\n        pos = s.find(s2, start)\n        if pos == -1:\n            break\n        result.append(pos)\n        start = pos + 1\n    return result"
  },
  {
    "id": 174,
    "response": "def check_email(s):\n    if s.count('@') != 1:\n        return False\n    local, domain = s.split('@')\n    if not local or not domain:\n        return False\n    if '.' not in domain:\n        return False\n    return True"
  },
  {
    "id": 175,
    "response": "def odd_position(lst):\n    for i in range(len(lst)):\n        if i % 2 == 1:  # odd index\n            if lst[i] % 2 == 0:\n                return False\n    return True"
  },
  {
    "id": 176,
    "response": "def count_vowels(s):\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    count = 0\n    for char in s:\n        if char.lower() in vowels:\n            count += 1\n    return count"
  },
  {
    "id": 177,
    "response": "def find_Sum(lst, n):\n    counts = Counter(lst)\n    return sum(element for element in lst if counts[element] == 1)"
  },
  {
    "id": 178,
    "response": "def pack_consecutive_duplicates(lst):\n    if not lst:\n        return []\n    result = []\n    current_group = [lst[0]]\n    for item in lst[1:]:\n        if item == current_group[-1]:\n            current_group.append(item)\n        else:\n            result.append(current_group)\n            current_group = [item]\n    result.append(current_group)\n    return result"
  },
  {
    "id": 179,
    "response": "def unique_sublists(lst):\n    unique = set()\n    n = len(lst)\n    for i in range(n):\n        for j in range(i, n):\n            sub = lst[i:j+1]\n            unique.add(tuple(sub))  # Wait, lists can't be added to a set, so convert to tuple\n    return len(unique)"
  },
  {
    "id": 180,
    "response": "def find_combinations(lst):\n    if not lst:\n        return []\n    elements = [tuple(t) for t in lst]\n    product = itertools.product(*elements)\n    return list(product)"
  },
  {
    "id": 181,
    "response": "def count_divisors(n):\n    sqrt_n = math.isqrt(n)\n    if sqrt_n * sqrt_n == n:\n        return 'odd'\n    else:\n        return 'even'"
  },
  {
    "id": 182,
    "response": "def Odd_Length_Sum(lst):\n    n = len(lst)\n    prefix_sum = [0] * (n + 1)\n    for i in range(n):\n        prefix_sum[i+1] = prefix_sum[i] + lst[i]\n    total = 0\n    for i in range(n):\n        for j in range(i, n):\n            length = j - i + 1\n            if length % 2 == 1:\n                total += prefix_sum[j+1] - prefix_sum[i]\n    return total"
  },
  {
    "id": 183,
    "response": "def rgb_to_hsv(r, g, b):\n    # Normalize RGB values to 0-1\n    r_norm = r / 255.0\n    g_norm = g / 255.0\n    b_norm = b / 255.0\n    \n    max_c = max(r_norm, g_norm, b_norm)\n    min_c = min(r_norm, g_norm, b_norm)\n    delta = max_c - min_c\n    \n    if delta == 0:\n        h = 0\n        s = 0\n    else:\n        if max_c == r_norm:\n            h = ((g_norm - b_norm) / delta) % 6\n        elif max_c == g_norm:\n            h = ((b_norm - r_norm) / delta) + 2\n        else:  # max_c == b_norm\n            h = ((r_norm - g_norm) / delta) + 4\n        \n        h *= 60  # Convert to degrees\n        s = (delta / max_c) * 100\n    \n    v = max_c * 100\n    \n    # Ensure hue is in the range [0, 360)\n    h = h % 360\n    \n    return (h, s, v)"
  },
  {
    "id": 184,
    "response": "def mul_even_odd(lst):\n    first_even = None\n    first_odd = None\n    for num in lst:\n        if num % 2 == 0:\n            if first_even is None:\n                first_even = num\n        else:\n            if first_odd is None:\n                first_odd = num\n    return first_even * first_odd"
  },
  {
    "id": 185,
    "response": "def tuple_str_int(s):\n    return tuple(int(x) for x in s)"
  },
  {
    "id": 186,
    "response": "def right_insertion(lst, n):\n    if not lst:\n        return 0\n    for i in range(len(lst)):\n        if lst[i] > n:\n            return i\n    return len(lst)"
  },
  {
    "id": 187,
    "response": "def text_match_three(s):\n    return bool(re.search(r'ab{3}', s))"
  },
  {
    "id": 188,
    "response": "def new_tuple(lst, s):\n    combined = lst + list(s)\n    return tuple(combined)"
  },
  {
    "id": 189,
    "response": "def perimeter_polygon(n, n2):\n    return n * n2"
  },
  {
    "id": 190,
    "response": "def even_position(lst):\n    for i in range(len(lst)):\n        if i % 2 == 0 and lst[i] % 2 != 0:\n            return False\n    return True"
  },
  {
    "id": 191,
    "response": "def remove_nested(tup):\n    result = []\n    for element in tup:\n        if isinstance(element, tuple):\n            result.extend(remove_nested(element))\n        else:\n            result.append(element)\n    return tuple(result)"
  },
  {
    "id": 192,
    "response": "def count_list(lst):\n    return len(lst)"
  },
  {
    "id": 193,
    "response": "def last(lst, n):\n    low = 0\n    high = len(lst) - 1\n    result = -1\n    while low <= high:\n        mid = (low + high) // 2\n        if lst[mid] == n:\n            result = mid\n            low = mid + 1\n        elif lst[mid] < n:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return result"
  },
  {
    "id": 194,
    "response": "def check_string(s):\n    if not s:\n        return False  # empty string\n    if s[-1] != 'b':\n        return False\n    return 'a' in s"
  },
  {
    "id": 195,
    "response": "def cheap_items(lst, n):\n    if not lst or n <= 0:\n        return []\n    return [item for item in lst if item < n]"
  },
  {
    "id": 196,
    "response": "def return_sum(dct):\n    return sum(dct.values())"
  },
  {
    "id": 197,
    "response": "def sum_in_Range(n, n2):\n    # Determine the lower and upper bounds\n    l = min(n, n2)\n    r = max(n, n2)\n    total = 0\n    # Iterate through each number in the range\n    for num in range(l, r + 1):\n        # Check if the number is odd and greater than zero\n        if num > 0 and num % 2 != 0:\n            total += num\n    return total"
  },
  {
    "id": 198,
    "response": "def _sum(lst):\n    total = 0\n    for num in lst:\n        total += num\n    return total"
  },
  {
    "id": 199,
    "response": "def left_Rotate(n, n2):\n    if n == 0:\n        return 0\n    bits = n.bit_length()\n    # Handle the case where n2 is larger than bits\n    k = n2 % bits\n    if k == 0:\n        return n\n    # Compute the rotated value\n    rotated = ( (n << k) | (n >> (bits - k)) ) & ((1 << bits) - 1)\n    return rotated"
  },
  {
    "id": 200,
    "response": "def remove_all_spaces(s):\n    return ''.join([char for char in s if not char.isspace()])"
  },
  {
    "id": 201,
    "response": "def test_three_equal(n, n2, n3):\n    unique = {n, n2, n3}\n    if len(unique) == 1:\n        return 3\n    elif len(unique) == 2:\n        return 2\n    else:\n        return 0"
  },
  {
    "id": 202,
    "response": "def count_rotation(lst, n):\n    # find the index of the minimum element\n    min_index = lst.index(min(lst))\n    return (n - min_index) % n"
  },
  {
    "id": 203,
    "response": "def is_Perfect_Square(n):\n    if n < 0:\n        return False\n    root = math.isqrt(n)\n    return root * root == n"
  },
  {
    "id": 204,
    "response": "def is_Product_Even(lst, n):\n    if n > len(lst):\n        return False\n    for i in range(n):\n        if lst[i] % 2 == 0:\n            return True\n    return False"
  },
  {
    "id": 205,
    "response": "def max_sum_list(lst):\n    if not lst:\n        return []  # or raise an error? The problem says to return a list, but maybe the input is non-empty.\n    current_max = max_so_far = lst[0]\n    start = 0\n    end = 0\n    for i in range(1, len(lst)):\n        if current_max + lst[i] > lst[i]:\n            current_max += lst[i]\n            end = i\n        else:\n            current_max = lst[i]\n            start = i\n            end = i\n        if current_max > max_so_far:\n            max_so_far = current_max\n            # record the start and end indices\n    return lst[start:end+1]"
  },
  {
    "id": 206,
    "response": "def max_run_uppercase(s):\n    max_count = 0\n    current_count = 0\n    for char in s:\n        if char.isupper():\n            current_count += 1\n            if current_count > max_count:\n                max_count = current_count\n        else:\n            current_count = 0\n    return max_count"
  },
  {
    "id": 207,
    "response": "def first_odd(lst):\n    for num in lst:\n        if num % 2 != 0:\n            return num\n    return None"
  },
  {
    "id": 208,
    "response": "def check_K(tup, n):\n    return n in tup"
  },
  {
    "id": 209,
    "response": "def check_smaller(tup, tup2):\n    if len(tup) != len(tup2):\n        return False\n    for a, b in zip(tup, tup2):\n        if not (a > b):\n            return False\n    return True"
  },
  {
    "id": 210,
    "response": "def count_variable(*args):"
  },
  {
    "id": 211,
    "response": "def check_identical(lst, lst2):\n    return lst == lst2"
  },
  {
    "id": 212,
    "response": "def road_rd(s):\n    return s.replace('road', 'rd.')"
  },
  {
    "id": 213,
    "response": "def string_length(s):\n    return len(s)"
  },
  {
    "id": 214,
    "response": "def rombus_area(n, n2):\n    return (n * n2) / 2"
  },
  {
    "id": 215,
    "response": "def sort_by_dnf(lst, n):\n    low = 0\n    mid = 0\n    high = n - 1\n    while mid <= high:\n        if lst[mid] == 0:\n            lst[low], lst[mid] = lst[mid], lst[low]\n            low += 1\n            mid += 1\n        elif lst[mid] == 1:\n            mid += 1\n        else:  # lst[mid] == 2\n            lst[mid], lst[high] = lst[high], lst[mid]\n            high -= 1"
  },
  {
    "id": 216,
    "response": "def clear_tuple(tup):\n    seen = set()\n    result = []\n    for element in tup:\n        if element not in seen:\n            seen.add(element)\n            result.append(element)\n    return tuple(result)"
  },
  {
    "id": 217,
    "response": "def div_of_nums(lst, n, n2):\n    return list(filter(lambda x: x % n == 0 or x % n2 == 0, lst))"
  },
  {
    "id": 218,
    "response": "def lower_ctr(s):\n    count = 0\n    for char in s:\n        if char.islower():\n            count +=1\n    return count"
  },
  {
    "id": 219,
    "response": "def count_duplic(lst):\n    if not lst:\n        return {}\n    freq = {}\n    current = lst[0]\n    count = 1\n    for num in lst[1:]:\n        if num == current:\n            count +=1\n        else:\n            freq[current] = count\n            current = num\n            count = 1\n    freq[current] = count\n    return freq"
  },
  {
    "id": 220,
    "response": "def check_monthnum_number(n):\n    if n == 2:\n        return True\n    else:\n        return False"
  },
  {
    "id": 221,
    "response": "def merge_dictionaries(dct, dct2):\n    merged = dct.copy()\n    merged.update(dct2)\n    return merged"
  },
  {
    "id": 222,
    "response": "def pass_validity(s):\n    if len(s) < 8:\n        return False\n    has_upper = any(char.isupper() for char in s)\n    has_lower = any(char.islower() for char in s)\n    has_digit = any(char.isdigit() for char in s)\n    has_space = any(char.isspace() for char in s)\n    return has_upper and has_lower and has_digit and not has_space"
  },
  {
    "id": 223,
    "response": "def check_substring(s, s2):\n    return bool(re.match(s2, s))"
  },
  {
    "id": 224,
    "response": "def remove_even(lst):\n    return [x for x in lst if x % 2 != 0]"
  },
  {
    "id": 225,
    "response": "def access_elements(lst, lst2):\n    return [lst[i] for i in lst2]"
  },
  {
    "id": 226,
    "response": "def check_Type_Of_Triangle(n, n2, n3):\n    # Check if the sides form a valid triangle\n    if n + n2 <= n3 or n + n3 <= n2 or n2 + n3 <= n:\n        return \"Not a valid triangle\"\n    \n    # Check for Equilateral triangle\n    if n == n2 == n3:\n        return \"Equilateral\"\n    \n    # Check for Isosceles triangle (exactly two sides equal)\n    elif n == n2 or n == n3 or n2 == n3:\n        return \"Isosceles\"\n    \n    # Otherwise, it's Scalene\n    else:\n        return \"Scalene\""
  },
  {
    "id": 227,
    "response": "def sum_column(lst, n):\n    total = 0\n    for row in lst:\n        total += row[n]\n    return total"
  },
  {
    "id": 228,
    "response": "def count_alpha_dig_spl(s):\n    alpha = 0\n    dig = 0\n    spl = 0\n    for char in s:\n        if char.isalpha():\n            alpha +=1\n        elif char.isdigit():\n            dig +=1\n        else:\n            spl +=1\n    return (alpha, dig, spl)"
  },
  {
    "id": 229,
    "response": "def second_frequent(lst):\n    counts = Counter(lst)\n    sorted_counts = sorted(counts.items(), key=lambda x: (-x[1], x[0]))\n    if len(sorted_counts) < 2:\n        return None\n    return sorted_counts[1][0]"
  },
  {
    "id": 230,
    "response": "def round_up(n, n2):\n    remainder = n % n2\n    if remainder == 0:\n        return n\n    else:\n        return n + (n2 - remainder)"
  },
  {
    "id": 231,
    "response": "def count_Pairs(lst, n):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if lst[i] + lst[j] == n:\n                count += 1\n    return count"
  },
  {
    "id": 232,
    "response": "def extract_max(s):\n    # Find all sequences of digits in the string\n    numbers = re.findall(r'\\d+', s)\n    if not numbers:\n        return None\n    # Convert the found strings to integers and return the maximum\n    return max(int(num) for num in numbers)"
  },
  {
    "id": 233,
    "response": "def get_key(dct):\n    return list(dct.keys())"
  },
  {
    "id": 234,
    "response": "def generate_matrix(n):\n    # Initialize the matrix with zeros\n    matrix = [[0 for _ in range(n)] for _ in range(n)]\n    \n    # Generate the list of powers of 2 up to n^2\n    max_val = n * n\n    power = 0\n    values = []\n    while (2 ** power) <= max_val:\n        values.append(2 ** power)\n        power += 1\n    \n    # Directions: right, down, left, up\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    current_dir = 0  # Start with right direction\n    \n    # Starting position\n    row, col = 0, 0\n    for value in values:\n        matrix[row][col] = value\n        # Calculate next position\n        next_row = row + directions[current_dir][0]\n        next_col = col + directions[current_dir][1]\n        \n        # Check if next position is valid\n        if 0 <= next_row < n and 0 <= next_col < n and matrix[next_row][next_col] == 0:\n            row, col = next_row, next_col\n        else:\n            # Change direction\n            current_dir = (current_dir + 1) % 4\n            row += directions[current_dir][0]\n            col += directions[current_dir][1]\n    \n    return matrix"
  },
  {
    "id": 235,
    "response": "def slope(n, n2, n3, n4):\n    delta_y = n4 - n2\n    delta_x = n3 - n\n    if delta_x == 0:\n        return \"undefined\"\n    return delta_y / delta_x"
  },
  {
    "id": 236,
    "response": "def max_sub_array_sum(lst, n):\n    # code here"
  },
  {
    "id": 237,
    "response": "def cube_Sum(n):\n    if n < 0:\n        return 0\n    return (n * (n + 1) // 2) ** 2"
  },
  {
    "id": 238,
    "response": "def min_Swaps(s, s2):\n    count = 0\n    for a, b in zip(s, s2):\n        if a != b:\n            count += 1\n    return count // 2"
  },
  {
    "id": 239,
    "response": "def sort_tuple(lst):\n    return sorted(lst, key=lambda x: x[0])"
  },
  {
    "id": 240,
    "response": "def Check_Solution(a, b, c):\n    if a == 0:\n        return False  # Not a quadratic equation\n    if b != 0:\n        return False  # Sum of roots is not zero\n    if (c / a) >= 0:\n        return False  # Product of roots is not negative\n    return True"
  },
  {
    "id": 241,
    "response": "def get_inv_count(lst, n):\n    if n <= 1:\n        return 0\n    mid = n // 2\n    left = lst[:mid]\n    right = lst[mid:]\n    \n    inv_count = 0\n    inv_count += get_inv_count(left, len(left))\n    inv_count += get_inv_count(right, len(right))\n    \n    i = j = k = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            lst[k] = left[i]\n            i += 1\n        else:\n            lst[k] = right[j]\n            j += 1\n            inv_count += len(left) - i\n        k += 1\n    \n    while i < len(left):\n        lst[k] = left[i]\n        i += 1\n        k += 1\n    \n    while j < len(right):\n        lst[k] = right[j]\n        j += 1\n        k += 1\n    \n    return inv_count"
  },
  {
    "id": 242,
    "response": "def get_odd_occurrence(lst, n):\n    result = 0\n    for i in range(n):\n        result ^= lst[i]\n    return result"
  },
  {
    "id": 243,
    "response": "def nth_super_ugly_number(n, lst):\n    if n == 0:\n        return None  # or handle as per requirements\n    heap = [1]\n    seen = set([1])\n    for _ in range(n):\n        current = heapq.heappop(heap)\n        for prime in lst:\n            new_num = current * prime\n            if new_num not in seen:\n                heapq.heappush(heap, new_num)\n                seen.add(new_num)\n    return current"
  },
  {
    "id": 244,
    "response": "def get_Number(n, k):\n    # generate array\n    array = list(range(1, n+1)) + list(range(1, n2+1))\n    return array[k-1]"
  },
  {
    "id": 245,
    "response": "def find_Digits(n):\n    if n == 0:\n        return 1\n    total = 0\n    for i in range(1, n+1):\n        total += math.log10(i)\n    return int(total) + 1"
  },
  {
    "id": 246,
    "response": "def find_platform(lst, lst2, n):\n    # Sort the arrival and departure times\n    lst.sort()\n    lst2.sort()\n    \n    platforms_needed = 0\n    result = 0\n    i = 0  # Pointer for arrival times\n    j = 0  # Pointer for departure times\n    \n    while i < n:\n        if lst[i] < lst2[j]:\n            # A train arrives before the previous one departs\n            platforms_needed += 1\n            i += 1\n            # Update the result if needed\n            result = max(result, platforms_needed)\n        else:\n            # A train departs before the next one arrives\n            platforms_needed -= 1\n            j += 1\n    \n    return result"
  },
  {
    "id": 247,
    "response": "def lcopy(lst):\n    return list(lst)"
  },
  {
    "id": 248,
    "response": "def area_trapezium(n, n2, n3):\n    return 0.5 * (n + n2) * n3"
  },
  {
    "id": 249,
    "response": "def sum_of_digits(n):\n    # Take absolute value to handle negative numbers\n    n = abs(n)\n    # Convert to string and sum each digit\n    return sum(int(digit) for digit in str(n))"
  },
  {
    "id": 250,
    "response": "def is_triangleexists(n, n2, n3):\n    # Check if all sides are positive\n    if n <= 0 or n2 <= 0 or n3 <= 0:\n        return False\n    # Sort the sides\n    sides = sorted([n, n2, n3])\n    x, y, z = sides\n    # Check triangle inequality\n    return x + y > z"
  },
  {
    "id": 251,
    "response": "def get_divisors(n):\n    divisors = []\n    for i in range(1, n+1):\n        if n % i == 0:\n            divisors.append(i)\n    return divisors"
  },
  {
    "id": 252,
    "response": "def remove_negs(lst):\n    return [x for x in lst if x >= 0]"
  },
  {
    "id": 253,
    "response": "def sum_of_factors(m):"
  },
  {
    "id": 254,
    "response": "def raw_heap(lst):\n    heapq.heapify(lst)\n    return lst"
  },
  {
    "id": 255,
    "response": "def check_Even_Parity(n):\n    # Convert to binary and count '1's\n    ones_count = bin(n).count('1')\n    # Return True if even\n    return ones_count % 2 == 0"
  },
  {
    "id": 256,
    "response": "def find_Min_Swaps(lst, n):\n    count_ones = 0\n    total_swaps = 0\n    for i in range(n):\n        if lst[i] == 1:\n            count_ones += 1\n        else:\n            total_swaps += count_ones\n    return total_swaps"
  },
  {
    "id": 257,
    "response": "def listify_list(lst):\n    return list(map(list, lst))"
  },
  {
    "id": 258,
    "response": "def count_list(lst):\n    return [x**2 for x in lst]"
  },
  {
    "id": 259,
    "response": "def sub_lists(lst):\n    result = []\n    n = len(lst)\n    for i in range(n):\n        for j in range(i, n):\n            result.append(lst[i:j+1])\n    return result"
  },
  {
    "id": 260,
    "response": "def check_alphanumeric(s):\n    if not s:\n        return False\n    last_char = s[-1]\n    # Check if the last character is alphanumeric\n    return last_char.isalnum()"
  },
  {
    "id": 261,
    "response": "def anagram_lambda(lst, s):\n    if not lst or not s:\n        return []\n    return list(filter(lambda x: sorted(x) == sorted(s), lst))"
  },
  {
    "id": 262,
    "response": "def n_common_words(s, n):\n    words = s.split()\n    counts = Counter(words)\n    common = counts.most_common(n)\n    return [word for word, count in common]"
  },
  {
    "id": 263,
    "response": "def find_longest_conseq_subseq(lst, n):\n    s = set(lst)\n    max_length = 0\n    for num in s:\n        if num - 1 not in s:\n            current_num = num\n            current_length = 1\n            while current_num + 1 in s:\n                current_num += 1\n                current_length += 1\n            max_length = max(max_length, current_length)\n    return max_length"
  },
  {
    "id": 264,
    "response": "def palindrome_lambda(lst):\n    return list(filter(lambda s: s == s[::-1], lst))"
  },
  {
    "id": 265,
    "response": "def ntimes_list(lst, n):\n    for _ in range(n):\n        print(lst)"
  },
  {
    "id": 266,
    "response": "def check_monthnumb(s):\n    thirty_one_days = {\"January\", \"March\", \"May\", \"July\", \"August\", \"October\", \"December\"}\n    return s in thirty_one_days"
  },
  {
    "id": 267,
    "response": "def min_Num(lst, n):\n    total = sum(lst)\n    if total % 2 == 0:\n        return 0\n    else:\n        return 1"
  },
  {
    "id": 268,
    "response": "def length_Of_Last_Word(s):\n    words = s.split()\n    if not words:\n        return 0\n    return len(words[-1])"
  },
  {
    "id": 269,
    "response": "def remove_list_range(lst, n, n2):\n    lower = min(n, n2)\n    upper = max(n, n2)\n    return [x for x in lst if lower <= x <= upper]"
  },
  {
    "id": 270,
    "response": "def sum_positivenum(lst):\n    positive_numbers = list(filter(lambda x: x > 0, lst))\n    return sum(positive_numbers)"
  },
  {
    "id": 271,
    "response": "def are_Rotations(s, s2):\n    if len(s) != len(s2):\n        return False\n    return s2 in s + s"
  },
  {
    "id": 272,
    "response": "def check_subset(lst, lst2):\n    for element in lst2:\n        if element not in lst:\n            return False\n    return True"
  },
  {
    "id": 273,
    "response": "def fibonacci(n):\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        return fibonacci(n-1) + fibonacci(n-2)"
  },
  {
    "id": 274,
    "response": "def check_Concat(s, s2):\n    if not s:\n        return len(s2) == 0\n    if len(s2) % len(s) != 0:\n        return False\n    k = len(s2) // len(s)\n    return s * k == s2"
  },
  {
    "id": 275,
    "response": "def min_difference(lst):\n    min_diff = float('inf')\n    n = len(lst)\n    for i in range(n):\n        for j in range(i+1, n):\n            current_diff = 0\n            for a, b in zip(lst[i], lst[j]):\n                current_diff += abs(a - b)\n            if current_diff < min_diff:\n                min_diff = current_diff\n    return min_diff"
  },
  {
    "id": 276,
    "response": "def lcm(n1, n2):\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n    \n    return (n1 * n2) // gcd(n1, n2)"
  },
  {
    "id": 277,
    "response": "def sort_String(s):\n    return ''.join(sorted(s))"
  },
  {
    "id": 278,
    "response": "def check_tuples(tup, lst):\n    return len(tup) == len(lst)"
  },
  {
    "id": 279,
    "response": "def text_match(s):\n    pattern = r'^a.+b$'\n    return bool(re.fullmatch(pattern, s))"
  },
  {
    "id": 280,
    "response": "def Check_Solution(a, b, c):\n    if a == 0:\n        if b == 0:\n            if c == 0:\n                return \"Infinite solutions\"\n            else:\n                return \"No solution\"\n        else:\n            return \"1 solution\"\n    else:\n        discriminant = b**2 - 4*a*c\n        if discriminant > 0:\n            return \"2 solutions\"\n        elif discriminant == 0:\n            return \"1 solution\"\n        else:\n            return \"No real solution\""
  },
  {
    "id": 281,
    "response": "def sum_even_odd(lst):\n    first_even = None\n    first_odd = None\n    for num in lst:\n        if num % 2 == 0 and first_even is None:\n            first_even = num\n        elif num % 2 != 0 and first_odd is None:\n            first_odd = num\n        if first_even is not None and first_odd is not None:\n            break\n    return first_even + first_odd"
  },
  {
    "id": 282,
    "response": "def parallelogram_perimeter(n, n2):\n    return 2 * (n + n2)"
  },
  {
    "id": 283,
    "response": "def div_of_nums(lst, n, n2):\n    return list(filter(lambda x: x % n == 0 and x % n2 == 0, lst))"
  },
  {
    "id": 284,
    "response": "def all_Bits_Set_In_The_Given_Range(n, n2, n3):\n    # Check if n2 <= n3 and they are non-negative\n    if n2 > n3 or n2 < 0 or n3 < 0:\n        return False\n    # Compute mask\n    mask = ((1 << (n3 + 1)) - 1) ^ ((1 << n2) - 1)\n    # Check if all bits in the range are set\n    return (n & mask) == mask"
  },
  {
    "id": 285,
    "response": "def is_Isomorphic(s, s2):"
  },
  {
    "id": 286,
    "response": "def sum_num(lst):\n    total = sum(lst)\n    length = len(lst)\n    return total / length"
  },
  {
    "id": 287,
    "response": "def is_odd(n):\n    return n & 1"
  },
  {
    "id": 288,
    "response": "def substract_elements(tup, tup2):\n    result = []\n    for a, b in zip(tup, tup2):\n        if isinstance(a, tuple) and isinstance(b, tuple):\n            result.append(substract_elements(a, b))\n        else:\n            result.append(a - b)\n    return tuple(result)"
  },
  {
    "id": 289,
    "response": "def reverse_list_lists(lst):\n    return [sublist[::-1] for sublist in lst]"
  },
  {
    "id": 290,
    "response": "def find_Extra(lst, lst2, n):\n    # Determine which list is longer\n    if len(lst) > len(lst2):\n        longer = lst\n        shorter = lst2\n    else:\n        longer = lst2\n        shorter = lst\n    \n    # Iterate through the elements of the shorter list\n    for i in range(len(shorter)):\n        if longer[i] != shorter[i]:\n            return i  # The extra element is at index i in the longer list\n    \n    # If all elements up to the shorter length are the same, the extra is at the end\n    return len(longer) - 1"
  },
  {
    "id": 291,
    "response": "def same_Length(n, n2):\n    return len(str(n)) == len(str(n2))"
  },
  {
    "id": 292,
    "response": "def remove_spaces(s):\n    return ' '.join(s.split())"
  },
  {
    "id": 293,
    "response": "def Extract(lst):\n    return lst[-1]"
  },
  {
    "id": 294,
    "response": "def float_to_tuple(s):\n    num = float(s)\n    integer_part = int(num)\n    fractional_part = int((num - integer_part) * 1000)  # assuming 3 decimal places\n    return (integer_part, fractional_part)"
  },
  {
    "id": 295,
    "response": "def max_sum_subseq(lst):\n    if not lst:\n        return 0\n    n = len(lst)\n    if n == 1:\n        return lst[0]\n    # Initialize dp array\n    dp = [0] * n\n    dp[0] = lst[0]\n    dp[1] = max(lst[0], lst[1])\n    \n    for i in range(2, n):\n        dp[i] = max(dp[i-1], dp[i-2] + lst[i])\n    \n    return dp[-1]"
  },
  {
    "id": 296,
    "response": "def sort_list_last(lst):\n    return sorted(lst)"
  },
  {
    "id": 297,
    "response": "def is_Word_Present(s, s2):\n    words = s.split()\n    return s2 in words"
  },
  {
    "id": 298,
    "response": "def extract_elements(lst, n):\n    if n <= 0 or n > len(lst):\n        return []\n    return [lst[i:i+n] for i in range(len(lst) - n + 1)]"
  },
  {
    "id": 299,
    "response": "def check(lst, n):\n    if n <= 1:\n        return True\n    count = 0\n    for i in range(n):\n        if lst[i] > lst[(i+1)%n]:\n            count +=1\n            if count >1:\n                return False\n    return count == 0 or count ==1"
  },
  {
    "id": 300,
    "response": "def match_num(s):\n    return s.startswith(str(5))  # if the specific number is 5"
  },
  {
    "id": 301,
    "response": "def num_comm_div(n, n2):\n    while n2 != 0:\n        n, n2 = n2, n % n2\n    return n"
  },
  {
    "id": 302,
    "response": "def find(n, n2):\n    return n % n2"
  },
  {
    "id": 303,
    "response": "def add_consecutive_nums(lst):\n    return sum(lst)"
  },
  {
    "id": 304,
    "response": "def sum_Of_Series(n):\n    if n < 0:\n        return 0\n    return (n * (n + 1) // 2) ** 2"
  },
  {
    "id": 305,
    "response": "def re_order(lst):\n    non_zeros = [x for x in lst if x != 0]\n    zeros = [0] * (len(lst) - len(non_zeros))\n    return non_zeros + zeros"
  },
  {
    "id": 306,
    "response": "def permutation_coefficient(n, k):\n    if k > n:\n        return 0\n    if k == 0:\n        return 1\n    result = 1\n    for i in range(k):\n        result *= (n - i)\n    return result"
  },
  {
    "id": 307,
    "response": "def remove_words(lst, lst2):\n    # Convert lst2 to a set for O(1) lookups\n    to_remove = set(lst2)\n    # Filter elements in lst that are not in to_remove\n    result = [word for word in lst if word not in to_remove]\n    return result"
  },
  {
    "id": 308,
    "response": "def same_order(lst, lst2):\n    common1 = [x for x in lst if x in lst2]\n    common2 = [x for x in lst2 if x in lst]\n    return common1 == common2"
  },
  {
    "id": 309,
    "response": "def average_Odd(n):\n    count = (n + 1) // 2\n    return count if count > 0 else 0"
  },
  {
    "id": 310,
    "response": "def no_of_subsequences(lst, n):\n    count = 0\n    m = len(lst)\n    for mask in range(1 << m):\n        product = 1\n        for i in range(m):\n            if mask & (1 << i):\n                product *= lst[i]\n        if product < n:\n            count += 1\n    return count"
  },
  {
    "id": 311,
    "response": "def find_Min_Sum(n):\n    if n == 0:\n        return 0\n    total = 0\n    for i in range(1, n+1):\n        if n % i == 0:\n            total += i\n    return total"
  },
  {
    "id": 312,
    "response": "def flatten(t):\n    result = []\n    for element in t:\n        if isinstance(element, tuple):\n            result.extend(flatten(element))\n        else:\n            result.append(element)\n    return result"
  },
  {
    "id": 313,
    "response": "def add_str(tup, s):\n    result = []\n    for element in tup:\n        result.append(element + s)\n    return result"
  },
  {
    "id": 314,
    "response": "def sum_elements(tup):\n    return sum(tup)"
  },
  {
    "id": 315,
    "response": "def has_subset_sum_divisible_by_modulus(lst, mod):\n    # Initialize the set of possible remainders\n    possible_remainders = {0}\n    for num in lst:\n        new_remainders = set()\n        for rem in possible_remainders:\n            new_rem = (rem + num) % mod\n            new_remainders.add(new_rem)\n        possible_remainders.update(new_remainders)\n        if 0 in possible_remainders:\n            return True\n    return False"
  },
  {
    "id": 316,
    "response": "def radix_sort(lst):\n    if not lst:\n        return lst\n    # Find the maximum number to determine the number of digits\n    max_num = max(lst)\n    # Determine the number of digits in the maximum number\n    max_digits = len(str(max_num))\n    \n    # Initialize buckets\n    buckets = [[] for _ in range(10)]\n    \n    # Process each digit from least significant to most\n    for digit_pos in range(max_digits):\n        # Distribute numbers into buckets based on the current digit\n        for num in lst:\n            # Extract the current digit\n            current_digit = (num // (10 ** digit_pos)) % 10\n            buckets[current_digit].append(num)\n        \n        # Collect numbers from buckets back into the list\n        lst = []\n        for bucket in buckets:\n            lst.extend(bucket)\n        \n        # Clear buckets for the next iteration\n        buckets = [[] for _ in range(10)]\n    \n    return lst"
  },
  {
    "id": 317,
    "response": "def largest_pos(lst):\n    max_pos = None\n    for num in lst:\n        if num > 0:\n            if max_pos is None or num > max_pos:\n                max_pos = num\n    return max_pos"
  },
  {
    "id": 318,
    "response": "def sqrt_root(n):\n    if n < 0:\n        raise ValueError(\"Negative number does not have a real square root.\")\n    if n == 0 or n == 1:\n        return n\n    low = 0\n    high = n\n    while low <= high:\n        mid = (low + high) // 2\n        mid_sq = mid * mid\n        if mid_sq == n:\n            return mid\n        elif mid_sq < n:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return high"
  },
  {
    "id": 319,
    "response": "def volume_tetrahedron(n):\n    if n <= 0:\n        raise ValueError(\"Edge length must be positive.\")\n    return (n ** 3) / (6 * math.sqrt(2))"
  },
  {
    "id": 320,
    "response": "def get_lcm(lst):\n    from math import gcd\n    \n    def lcm(a, b):\n        return a * b // gcd(a, b)\n    \n    if not lst:\n        return 0\n    result = lst[0]\n    for num in lst[1:]:\n        result = lcm(result, num)\n    return result"
  },
  {
    "id": 321,
    "response": "def check_isosceles(n, n2, n3):\n    return n == n2 or n2 == n3 or n == n3"
  },
  {
    "id": 322,
    "response": "def lbs(lst):\n    if not lst:\n        return 0\n    n = len(lst)\n    inc = [1] * n\n    dec = [1] * n"
  },
  {
    "id": 323,
    "response": "def check_string(s):\n    return any(c.isupper() for c in s) and any(c.islower() for c in s) and any(c.isdigit() for c in s) and len(s) == 8"
  },
  {
    "id": 324,
    "response": "def max_sum_increasing_subsequence(lst, n):\n    if n == 0:\n        return 0\n    dp = [0] * n\n    dp[0] = lst[0]\n    max_sum = lst[0]\n    for i in range(1, n):\n        dp[i] = lst[i]\n        for j in range(i):\n            if lst[j] < lst[i]:\n                dp[i] = max(dp[i], dp[j] + lst[i])\n        max_sum = max(max_sum, dp[i])\n    return max_sum"
  },
  {
    "id": 325,
    "response": "def parallel_lines(lst, lst2):\n    # Extract coefficients for the line equations ax + by + c = 0\n    a1, b1, c1 = lst\n    a2, b2, c2 = lst2\n    \n    # Compute direction vectors (b1, -a1) and (b2, -a2)\n    dir1 = (b1, -a1)\n    dir2 = (b2, -a2)\n    \n    # Compute cross product of direction vectors\n    cross_product = dir1[0] * dir2[1] - dir1[1] * dir2[0]\n    \n    # If cross product is zero, lines are parallel\n    return cross_product == 0"
  },
  {
    "id": 326,
    "response": "def capitalize_first_last_letters(s):\n    words = s.split()\n    processed_words = []\n    for word in words:\n        if len(word) == 0:\n            processed_words.append('')\n            continue\n        if len(word) == 1:\n            processed_word = word.upper()\n        else:\n            processed_word = word[0].upper() + word[1:-1] + word[-1].upper()\n        processed_words.append(processed_word)\n    return ' '.join(processed_words)"
  },
  {
    "id": 327,
    "response": "def get_pairs_count(lst, n, n2):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if lst[i] + lst[j] == n or lst[i] + lst[j] == n2:\n                count +=1\n    return count"
  },
  {
    "id": 328,
    "response": "def min_length(lst):\n    if not lst:\n        return 0\n    return min(len(element) for element in lst)"
  },
  {
    "id": 329,
    "response": "def jacobsthal_lucas(n):\n    if n == 0:\n        return 2\n    elif n == 1:\n        return 1\n    a, b = 2, 1\n    for _ in range(2, n + 1):\n        a, b = b, b + 2 * a\n    return b"
  },
  {
    "id": 330,
    "response": "def negative_count(lst):\n    negative_count = sum(1 for num in lst if num < 0)\n    total = len(lst)\n    if total == 0:\n        return 0.0\n    return negative_count / total"
  },
  {
    "id": 331,
    "response": "def min_coins(lst, n, n2):\n    # process each value in lst\n    result = []\n    for val in lst:\n        # compute min coins for val\n        # append to result\n    return result"
  },
  {
    "id": 332,
    "response": "def check_permutation(s, s2):\n    if len(s) != len(s2):\n        return False\n    return sorted(s) == sorted(s2)"
  },
  {
    "id": 333,
    "response": "def remove_datatype(tup, param):\n    return tuple(element for element in tup if type(element) != param)"
  },
  {
    "id": 334,
    "response": "def search_literal(s, s2):\n    len_s = len(s)\n    len_s2 = len(s2)\n    if len_s2 == 0:\n        return 0\n    if len_s < len_s2:\n        return -1\n    for i in range(len_s - len_s2 + 1):\n        if s[i:i+len_s2] == s2:\n            return i\n    return -1"
  },
  {
    "id": 335,
    "response": "def topbottom_surfacearea(n):\n    if n < 0:\n        return 0  # Or raise an error, but the problem might expect a valid input\n    return math.pi * n * n"
  },
  {
    "id": 336,
    "response": "def nth_items(lst, n):\n    return lst[n-1]"
  },
  {
    "id": 337,
    "response": "def first_repeated_word(s):\n    words = s.split()\n    seen = set()\n    for word in words:\n        if word in seen:\n            return word\n        seen.add(word)\n    return None"
  },
  {
    "id": 338,
    "response": "def string_list_to_tuple(input_list):\n    return tuple(input_list)"
  },
  {
    "id": 339,
    "response": "def basesnum_coresspondingnum(lst, lst2):\n    if len(lst) != len(lst2):\n        return []\n    result = []\n    for a, b in zip(lst, lst2):\n        result.append(a ** b)\n    return result"
  },
  {
    "id": 340,
    "response": "def find_Diff(lst, n):\n    freq = Counter(lst)\n    max_freq = max(freq.values())\n    min_freq = min(freq.values())\n    return max_freq - min_freq"
  },
  {
    "id": 341,
    "response": "def check_abundant(n):"
  },
  {
    "id": 342,
    "response": "def fill_spaces(s):\n    return re.sub(r'[ ,.]', '|', s)"
  },
  {
    "id": 343,
    "response": "def add_and_print(n, n2):\n    print(n + n2)"
  },
  {
    "id": 344,
    "response": "def flatten_tuple(lst):\n    result = []\n    for element in lst:\n        if isinstance(element, tuple):\n            result.extend(flatten_tuple(element))\n        else:\n            result.append(element)\n    return result"
  },
  {
    "id": 345,
    "response": "def toggle_F_and_L_bits(n):\n    if n == 0:\n        return 0  # or some other handling\n    bits = n.bit_length()\n    mask = (1 << (bits - 1)) | 1\n    return n ^ mask"
  },
  {
    "id": 346,
    "response": "def last_occurence_char(s, s2):\n    if not s2:\n        return -1\n    len_s = len(s)\n    len_s2 = len(s2)\n    if len_s2 > len_s:\n        return -1\n    for i in range(len_s - len_s2 + 1):\n        if s[i:i+len_s2] == s2:\n            return i\n    return -1"
  },
  {
    "id": 347,
    "response": "def Total_Hamming_Distance(n):\n    total = 0\n    for i in range(n):\n        xor = i ^ (i + 1)\n        total += bin(xor).count('1')\n    return total"
  },
  {
    "id": 348,
    "response": "def longest_increasing_subsequence(lst):\n    tails = []\n    for num in lst:\n        idx = bisect.bisect_left(tails, num)\n        if idx == len(tails):\n            tails.append(num)\n        else:\n            tails[idx] = num\n    return len(tails)"
  },
  {
    "id": 349,
    "response": "def odd_Num_Sum(n):\n    total = 0\n    for i in range(1, n+1):\n        odd = 2*i -1\n        total += odd **5\n    return total"
  },
  {
    "id": 350,
    "response": "def find_Max(lst, n, n2):\n    # find maximum in lst[n : n2+1]\n    return max(lst[n:n2+1])"
  },
  {
    "id": 351,
    "response": "def extract_column(lst, n):\n    return [row[n] for row in lst]"
  },
  {
    "id": 352,
    "response": "def Seq_Linear(lst):\n    if len(lst) <= 1:\n        return True\n    diff = lst[1] - lst[0]\n    for i in range(2, len(lst)):\n        if lst[i] - lst[i-1] != diff:\n            return False\n    return True"
  },
  {
    "id": 353,
    "response": "def tuple_to_float(tup):\n    if not tup:\n        return 0.0\n    str_num = ''.join(str(x) for x in tup)\n    return float(str_num)"
  },
  {
    "id": 354,
    "response": "def find_odd(lst):\n    for num in lst:\n        if num % 2 != 0:\n            return num\n    return None  # or raise an error if no odd found"
  },
  {
    "id": 355,
    "response": "def difference(n):\n    sum_numbers = n * (n + 1) // 2\n    return sum_numbers * (sum_numbers - 1)"
  },
  {
    "id": 356,
    "response": "def find_Odd_Pair(lst, n):\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if lst[i] ^ lst[j] == n:\n                return (lst[i], lst[j])\n    return None"
  },
  {
    "id": 357,
    "response": "def toggle_string(s):\n    return s.swapcase()"
  },
  {
    "id": 358,
    "response": "def digit_distance_nums(n, n2):\n    # Convert numbers to strings\n    str_n = str(n)\n    str_n2 = str(n2)\n    \n    # Determine the maximum length\n    max_len = max(len(str_n), len(str_n2))\n    \n    # Pad the shorter string with leading zeros\n    str_n = str_n.zfill(max_len)\n    str_n2 = str_n2.zfill(max_len)\n    \n    # Calculate the digit distance\n    distance = 0\n    for d1, d2 in zip(str_n, str_n2):\n        distance += abs(int(d1) - int(d2))\n    \n    return distance"
  },
  {
    "id": 359,
    "response": "def max_sub_array_sum(lst, n):\n    if not lst or n <= 0 or n > len(lst):\n        return 0\n    current_sum = sum(lst[:n])\n    max_sum = current_sum\n    for i in range(n, len(lst)):\n        current_sum += lst[i] - lst[i - n]\n        if current_sum > max_sum:\n            max_sum = current_sum\n    return max_sum"
  },
  {
    "id": 360,
    "response": "def union_elements(tup, tup2):\n    # Convert both tuples to sets and take their union\n    set1 = set(tup)\n    set2 = set(tup2)\n    union_set = set1.union(set2)\n    # Convert the result back to a tuple and return\n    return tuple(union_set)"
  },
  {
    "id": 361,
    "response": "def assign_elements(lst, tuple), but the example given is assign_elements(lst), which implies that the tuple is not part of the function's parameters."
  },
  {
    "id": 362,
    "response": "def Find_Max_Length(lst):\n    if not lst:\n        return 0\n    last_seen = {}\n    max_length = 0\n    left = 0\n    for right in range(len(lst)):\n        current = lst[right]\n        if current in last_seen and last_seen[current] >= left:\n            left = last_seen[current] + 1\n        last_seen[current] = right\n        max_length = max(max_length, right - left + 1)\n    return max_length"
  },
  {
    "id": 363,
    "response": "def extract_values(s):\n    result = []\n    current_value = None\n    in_quotes = False\n    quote_type = None  # 'single' or 'double'\n    for char in s:\n        if char in '\"\\'':\n            if not in_quotes:\n                # Start of a quoted string\n                in_quotes = True\n                quote_type = char\n                current_value = ''\n            else:\n                # End of the quoted string\n                if char == quote_type:\n                    in_quotes = False\n                    result.append(current_value)\n                    current_value = None\n                else:\n                    # Different quote type, but according to the problem, maybe we should consider it as part of the string?\n                    # Wait, but according to the problem statement, the function should extract values between quotes. So if the quotes are of different types, like \"Hello 'world'\", then the first quote is double, then the next is single. But according to the problem, the function should extract the value between the quotes. But in this case, the first quote is double, then the next is single. So perhaps the function should consider that the first quote is the start, and the next quote (of any type) is the end. But that's not correct. Because the quotes must be of the same type to close."
  },
  {
    "id": 364,
    "response": "def count_Pairs(lst, n):\n    even_count = 0\n    odd_count = 0\n    for num in lst:\n        if num % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    return even_count * odd_count"
  },
  {
    "id": 365,
    "response": "def split(s):\n    return list(s)"
  },
  {
    "id": 366,
    "response": "def sum_digits(n):\n    return sum(int(digit) for digit in str(n))"
  },
  {
    "id": 367,
    "response": "def issort_list(lst):\n    for i in range(len(lst) - 1):\n        if lst[i] > lst[i + 1]:\n            return False\n    return True"
  },
  {
    "id": 368,
    "response": "def empty_list(n):\n    return [{} for _ in range(n)]"
  },
  {
    "id": 369,
    "response": "def sort_sublists(lst):\n    return [sorted(sublist) for sublist in lst]"
  },
  {
    "id": 370,
    "response": "def remove_words(lst, lst2):\n    to_remove = set(lst2)\n    return [word for word in lst if word not in to_remove]"
  },
  {
    "id": 371,
    "response": "def max_sum_pair_diff_lessthan_K(lst, K):"
  },
  {
    "id": 372,
    "response": "def two_unique_nums(lst):\n    freq = {}\n    for num in lst:\n        if num in freq:\n            freq[num] += 1\n        else:\n            freq[num] = 1\n    duplicates = [k for k, v in freq.items() if v > 1]\n    return duplicates[:2]"
  },
  {
    "id": 373,
    "response": "def unique_product(lst):\n    unique_nums = set(lst)\n    product = 1\n    for num in unique_nums:\n        product *= num\n    return product"
  },
  {
    "id": 374,
    "response": "def surfacearea_cylinder(n, n2):\n    return 2 * math.pi * n * (n + n2)"
  },
  {
    "id": 375,
    "response": "def count_no(n, n2, n3, n4):\n    count = 0\n    num = 1\n    while True:\n        if not (num % n2 == 0 or num % n3 == 0 or num % n4 == 0):\n            count +=1\n            if count == n:\n                return num\n        num +=1"
  },
  {
    "id": 376,
    "response": "def is_Sub_Array(lst, lst2, n, n2):\n    if n2 > n:\n        return False\n    for i in range(n - n2 + 1):\n        if lst[i:i+n2] == lst2:\n            return True\n    return False"
  },
  {
    "id": 377,
    "response": "def last_Digit_Factorial(n):\n    if n >= 5:\n        return 0\n    # Compute factorial and return last digit\n    result = 1\n    for i in range(1, n+1):\n        result *= i\n    return result % 10"
  },
  {
    "id": 378,
    "response": "def interleave_lists(lst, lst2, lst3):\n    if len(lst) != len(lst2) or len(lst) != len(lst3):\n        raise ValueError(\"All lists must have the same length.\")\n    result = []\n    for i in range(len(lst)):\n        result.append(lst[i])\n        result.append(lst2[i])\n        result.append(lst3[i])\n    return result"
  },
  {
    "id": 379,
    "response": "def find_dissimilar(tup, tup2):\n    set1 = set(tup)\n    set2 = set(tup2)\n    dissimilar_set = set1.symmetric_difference(set2)\n    return tuple(dissimilar_set)"
  },
  {
    "id": 380,
    "response": "def extract_even(tup):\n    result = []\n    for element in tup:\n        if isinstance(element, tuple):\n            # Recurse into this tuple\n            result.extend(extract_even(element))\n        else:\n            # Check if it's even\n            if element % 2 == 0:\n                result.append(element)\n    return result"
  },
  {
    "id": 381,
    "response": "def surface_Area(n, n2):\n    if n <= 0 or n2 <= 0:\n        return 0  # Assuming non-positive values result in zero area\n    base_area = n * n\n    lateral_area = 2 * n * n2\n    total_area = base_area + lateral_area\n    return total_area"
  },
  {
    "id": 382,
    "response": "def my_dict(dct):\n    return len(dct) == 0"
  },
  {
    "id": 383,
    "response": "def catalan_number(n):\n    if n < 0:\n        return 0\n    result = 1\n    for i in range(1, n+1):\n        result = result * (2 * n - i + 1) // i\n    return result"
  },
  {
    "id": 384,
    "response": "def find_adverbs(s):\n    # Use regex to find all words ending with 'ly'\n    pattern = r'\\b\\w+ly\\b'\n    matches = re.finditer(pattern, s)\n    result = []\n    for match in matches:\n        word = match.group()\n        start = match.start()\n        result.append((word, start))\n    return result"
  },
  {
    "id": 385,
    "response": "def expensive_items(lst, n):\n    return [item for item in lst if item > n]"
  },
  {
    "id": 386,
    "response": "def split_Arr(lst, n, n2):\n    first_part = lst[:n]\n    second_part = lst[n:]\n    return second_part + first_part"
  },
  {
    "id": 387,
    "response": "def list_tuple(lst):\n    return tuple(lst)"
  },
  {
    "id": 388,
    "response": "def big_diff(lst):\n    return max(lst) - min(lst)"
  },
  {
    "id": 389,
    "response": "def perfect_squares(n, n2):\n    lower = min(n, n2)\n    upper = max(n, n2)\n    if upper < 0:\n        return 0\n    # Compute a\n    if lower < 0:\n        a = 0\n    else:\n        a = math.isqrt(lower)\n        if a * a < lower:\n            a += 1\n    # Compute b\n    b = math.isqrt(upper)\n    if b * b > upper:\n        b -= 1\n    if a > b:\n        return 0\n    else:\n        return b - a + 1"
  },
  {
    "id": 390,
    "response": "def polar_rect(r, theta):\n    x = r * math.cos(theta)\n    y = r * math.sin(theta)\n    return (x, y)"
  },
  {
    "id": 391,
    "response": "def swap_List(lst):\n    if len(lst) <= 1:\n        return lst\n    lst[0], lst[-1] = lst[-1], lst[0]\n    return lst"
  },
  {
    "id": 392,
    "response": "def sum_Of_product(n):\n    return 2 ** n"
  },
  {
    "id": 393,
    "response": "def removezero_ip(s):\n    parts = s.split('.')\n    processed = [str(int(part)) for part in parts]\n    return '.'.join(processed)"
  },
  {
    "id": 394,
    "response": "def diff_even_odd(lst):\n    first_even = None\n    first_odd = None\n    for num in lst:\n        if num % 2 == 0:\n            if first_even is None:\n                first_even = num\n        else:\n            if first_odd is None:\n                first_odd = num\n    return first_even - first_odd"
  },
  {
    "id": 395,
    "response": "def min_swaps(s, s2):\n    if len(s) != len(s2):\n        return -1\n    count_0to1 = 0\n    count_1to0 = 0\n    for c1, c2 in zip(s, s2):\n        if c1 == '0' and c2 == '1':\n            count_0to1 +=1\n        elif c1 == '1' and c2 == '0':\n            count_1to0 +=1\n    if count_0to1 != count_1to0:\n        return -1\n    return count_0to1"
  },
  {
    "id": 396,
    "response": "def tuple_size(tup):\n    return len(tup)"
  },
  {
    "id": 397,
    "response": "def find_kth(lst, lst2, n, n2, n3):\n    merged = []\n    i = j = 0\n    while i < n and j < n2:\n        if lst[i] < lst2[j]:\n            merged.append(lst[i])\n            i += 1\n        else:\n            merged.append(lst2[j])\n            j += 1\n    # Add remaining elements\n    while i < n:\n        merged.append(lst[i])\n        i += 1\n    while j < n2:\n        merged.append(lst2[j])\n        j += 1\n    return merged[n3 - 1]"
  },
  {
    "id": 398,
    "response": "def armstrong_number(n):\n    # Convert the number to a string to process each digit\n    digits = list(str(n))\n    # Calculate the number of digits\n    num_digits = len(digits)\n    # Compute the sum of each digit raised to the power of num_digits\n    sum_powers = sum(int(digit) ** num_digits for digit in digits)\n    # Check if the sum equals the original number\n    return sum_powers == n"
  },
  {
    "id": 399,
    "response": "def sum_average(n):\n    if n <= 0:\n        return (0, 0)  # or raise an error, but the problem might not consider this\n    total_sum = n * (n + 1) // 2\n    average = total_sum / n\n    return (total_sum, average)"
  },
  {
    "id": 400,
    "response": "def is_Even(n):\n    return (n & 1) == 0"
  }
]