[
  {
    "id": 1,
    "response": ""
  },
  {
    "id": 2,
    "response": "def first_repeated_char(s):\n    seen = set()\n    for char in s:\n        if char in seen:\n            return char\n        seen.add(char)\n    return None"
  },
  {
    "id": 3,
    "response": "def get_ludic(n):"
  },
  {
    "id": 4,
    "response": "def reverse_words(s):\n    words = s.split()\n    reversed_words = [word[::-1] for word in words]\n    return ' '.join(reversed_words)"
  },
  {
    "id": 5,
    "response": "def prime_num(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True"
  },
  {
    "id": 6,
    "response": "def radian_degree(n):\n    return n * math.pi / 180.0"
  },
  {
    "id": 7,
    "response": "def find_literals(s, s2):\n    pattern = re.escape(s2)\n    match = re.search(pattern, s)\n    if match:\n        return match.start()\n    else:\n        return -1"
  },
  {
    "id": 8,
    "response": "def bell_number(n):\n    if n == 0:\n        return 1\n    # Initialize Bell triangle\n    bell_triangle = [[0] * (n) for _ in range(n)]\n    bell_triangle[0][0] = 1\n    for i in range(1, n):\n        bell_triangle[i][0] = bell_triangle[i-1][i-1]\n        for j in range(1, i+1):\n            bell_triangle[i][j] = bell_triangle[i][j-1] + bell_triangle[i-1][j-1]\n    return bell_triangle[n-1][0]"
  },
  {
    "id": 9,
    "response": "def floor_Min(*args):\n    return min(args)"
  },
  {
    "id": 10,
    "response": "def remove_kth_element(lst, n):\n    lst.pop(n-1)\n    return lst"
  },
  {
    "id": 11,
    "response": "def max_of_nth(lst, n):\n    if not lst:\n        return None  # Handle empty list case\n    max_val = lst[0][n]\n    for t in lst[1:]:\n        if t[n] > max_val:\n            max_val = t[n]\n    return max_val"
  },
  {
    "id": 12,
    "response": "def merge(lst):\n    if not lst:\n        return []\n    if len(lst) == 1:\n        return lst\n    new_lst = [lst[0] + lst[-1]] + lst[1:-1]\n    return new_lst"
  },
  {
    "id": 13,
    "response": "def maximum_value(lst):\n    # Flatten the list of tuples into a single list of values\n    flat_list = [item for sublist in lst for item in sublist]\n    # Return the maximum value\n    return max(flat_list)"
  },
  {
    "id": 14,
    "response": "def cummulative_sum(lst):\n    total = 0\n    for t in lst:\n        total += sum(t)\n    return total"
  },
  {
    "id": 15,
    "response": "def average_tuple(tup):. Then, calculate the sum using sum(tup), get the length with len(tup), then return sum(tup) / len(tup)."
  },
  {
    "id": 16,
    "response": "def tuple_modulo(tup, tup2):\n    if len(tup) != len(tup2):\n        raise ValueError(\"Tuples must be of the same length\")\n    result = []\n    for a, b in zip(tup, tup2):\n        if b == 0:\n            raise ValueError(\"Division by zero is not allowed\")\n        result.append(a % b)\n    return tuple(result)"
  },
  {
    "id": 17,
    "response": ""
  },
  {
    "id": 18,
    "response": "def div_list(lst, lst2):\n    if len(lst) != len(lst2):\n        return []\n    return list(map(lambda x, y: x / y, lst, lst2))"
  },
  {
    "id": 19,
    "response": "def move_num(s):\n    digits = []\n    others = []\n    for char in s:\n        if char.isdigit():\n            digits.append(char)\n        else:\n            others.append(char)\n    return ''.join(digits + others)"
  },
  {
    "id": 20,
    "response": ""
  },
  {
    "id": 21,
    "response": "def increment_numerics(lst, n):\n    result = []\n    for s in lst:\n        # Use regex to find all numeric parts and replace them\n        new_s = re.sub(r'(\\d+)', lambda m: str(int(m.group(1)) + n), s)\n        result.append(new_s)\n    return result"
  },
  {
    "id": 22,
    "response": "def get_median(lst, lst2, n):\n    if n == 0:\n        return 0\n    # Ensure lst is the smaller array for binary search\n    if len(lst) > len(lst2):\n        lst, lst2 = lst2, lst\n    low, high = 0, n\n    while low <= high:\n        partition1 = (low + high) // 2\n        partition2 = n - partition1\n        # Handle edge cases for partitions\n        max_left1 = lst[partition1 - 1] if partition1 > 0 else -float('inf')\n        min_right1 = lst[partition1] if partition1 < n else float('inf')\n        max_left2 = lst2[partition2 - 1] if partition2 > 0 else -float('inf')\n        min_right2 = lst2[partition2] if partition2 < n else float('inf')\n        # Check if the partition is correct\n        if max_left1 <= min_right2 and max_left2 <= min_right1:\n            # Calculate the median\n            max_left = max(max_left1, max_left2)\n            min_right = min(min_right1, min_right2)\n            return (max_left + min_right) / 2\n        elif max_left1 > min_right2:\n            # Move partition1 to the left\n            high = partition1 - 1\n        else:\n            # Move partition1 to the right\n            low = partition1 + 1\n    return 0"
  },
  {
    "id": 23,
    "response": "def nth_nums(lst, n):\n    return list(map(lambda x: x ** n, lst))"
  },
  {
    "id": 24,
    "response": "def is_upper(s):\n    return s.upper()"
  },
  {
    "id": 25,
    "response": "def swap_List(lst):\n    if len(lst) < 2:\n        return lst\n    lst[0], lst[-1] = lst[-1], lst[0]\n    return lst"
  },
  {
    "id": 26,
    "response": "def triangle_area(n):\n    return n * n"
  },
  {
    "id": 27,
    "response": "def find_First_Missing(lst):\n    s = set(lst)\n    i = 1\n    while True:\n        if i not in s:\n            return i\n        i += 1"
  },
  {
    "id": 28,
    "response": "def replace_spaces(s):\n    return s.replace(' ', '%20')"
  },
  {
    "id": 29,
    "response": "def Split(lst):\n    return [x for x in lst if x % 2 == 0]"
  },
  {
    "id": 30,
    "response": "def get_coordinates(tup):\n    result = []\n    for i in range(len(tup) - 1):\n        result.append( (tup[i], tup[i+1]) )\n    return result"
  },
  {
    "id": 31,
    "response": "def replace_spaces(s):\n    def replace(match):\n        c = match.group(0)\n        if c.isspace():\n            return '_'\n        elif c == '_':\n            return ' '\n        else:\n            return c  # leave other characters unchanged\n    return re.sub(r'[ \\t\\n\\r\\f\\v_]', replace, s)"
  },
  {
    "id": 32,
    "response": "def move_zero(lst):\n    non_zeros = [x for x in lst if x != 0]\n    zeros = [x for x in lst if x == 0]\n    return non_zeros + zeros"
  },
  {
    "id": 33,
    "response": "def pair_OR_Sum(lst, n):\n    total = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            total += lst[i] ^ lst[j]\n    return total"
  },
  {
    "id": 34,
    "response": "def even_Power_Sum(n):\n    total = 0\n    for k in range(1, n+1):\n        total += (2*k)**4\n    return total"
  },
  {
    "id": 35,
    "response": "def heap_sort(lst):\n    def heapify(arr, n, i):\n        largest = i\n        left = 2 * i + 1\n        right = 2 * i + 2"
  },
  {
    "id": 36,
    "response": "def Check_Solution(n, n2, n3):\n    discriminant = n2**2 - 4 * n * n3\n    return discriminant > 0"
  },
  {
    "id": 37,
    "response": "def noprofit_noloss(n, n2):\n    return n == n2"
  },
  {
    "id": 38,
    "response": "def wind_chill(n, n2):\n    # n is temperature in Fahrenheit, n2 is wind speed in mph\n    if n2 < 3:\n        return n\n    # Calculate the wind chill using the formula\n    v_pow = n2 ** 0.16\n    wind_chill = 35.74 + 0.6215 * n - 35.75 * v_pow + 0.4275 * n * v_pow\n    return round(wind_chill, 1)"
  },
  {
    "id": 39,
    "response": "def sample_nam(lst):\n    total = 0\n    for name in lst:\n        if name and name[0].islower():\n            total += len(name)\n    return total"
  },
  {
    "id": 40,
    "response": "def remove_parenthesis(lst):\n    return [re.sub(r'\\([^)]*\\)', '', s) for s in lst]"
  },
  {
    "id": 41,
    "response": "def is_nonagonal(n):\n    if n < 1:\n        return False\n    discriminant = 1 + 56 * n\n    sqrt_discriminant = int(discriminant ** 0.5)\n    if sqrt_discriminant * sqrt_discriminant != discriminant:\n        return False\n    k = (5 + sqrt_discriminant) / 14\n    return k.is_integer() and k > 0"
  },
  {
    "id": 42,
    "response": "def remove_similar_row(lst):\n    seen = set()\n    result = []\n    for row in lst:\n        if row not in seen:\n            seen.add(row)\n            result.append(row)\n    return result"
  },
  {
    "id": 43,
    "response": "def text_match_wordz_middle(s):\n    if len(s) < 2:\n        return False\n    for i in range(1, len(s)-1):\n        if s[i] == 'z':\n            return True\n    return False"
  },
  {
    "id": 44,
    "response": "def reverse_Array_Upto_K(lst, n):\n    if n <= 0:\n        return lst\n    n = min(n, len(lst))\n    return lst[:n][::-1] + lst[n:]"
  },
  {
    "id": 45,
    "response": "def find_k_product(lst, n): product = 1 for t in lst: product *= t[n] return product. But wait, what if n is negative? Or if the list is empty? Well, the problem might not consider those edge cases. Let's proceed with that. Let's test with an example. Suppose lst is [(1,2,3), (4,5,6)], n is 1. Then the elements at index 1 are 2 and 5. Product is 2*5=10. So the function should return 10. So the code seems correct. But what if the tuples are of different lengths? Like if one tuple has length 2 and n is 1. Then it would raise an error. But the problem statement might not require handling that. So the code is straightforward.\n</thought>"
  },
  {
    "id": 46,
    "response": "def No_of_cubes(n, n2):\n    return (n // n2) **3"
  },
  {
    "id": 47,
    "response": "def split_upperstring(s):\n    result = []\n    start = 0\n    for i, char in enumerate(s):\n        if char.isupper():\n            result.append(s[start:i])\n            start = i + 1\n    result.append(s[start:])\n    return result"
  },
  {
    "id": 48,
    "response": "def exchange_elements(lst):\n    for i in range(0, len(lst)-1, 2):\n        lst[i], lst[i+1] = lst[i+1], lst[i]\n    return lst"
  },
  {
    "id": 49,
    "response": "def sum_Range_list(lst, n, n2):\n    return sum(lst[n:n2+1])"
  },
  {
    "id": 50,
    "response": "def are_Equal(lst, lst2, n, n2):\n    if n != n2:\n        return False\n    for i in range(n):\n        if lst[i] != lst2[i]:\n            return False\n    return True"
  },
  {
    "id": 51,
    "response": "def check_subset(tup, tup2):\n    return set(tup).issubset(set(tup2))"
  },
  {
    "id": 52,
    "response": "def matrix_to_list(lst):\n    return list(zip(*lst))"
  },
  {
    "id": 53,
    "response": "def grouping_dictionary(lst):\n    result = {}\n    for index, element in enumerate(lst):\n        if element in result:\n            result[element].append(index)\n        else:\n            result[element] = [index]\n    return result"
  },
  {
    "id": 54,
    "response": "def rectangle_perimeter(n, n2):\n    return 2 * (n + n2)"
  },
  {
    "id": 55,
    "response": "def fifth_Power_Sum(n):\n    return (n**2 * (n+1)**2 * (2*n**2 + 2*n -1)) // 12"
  },
  {
    "id": 56,
    "response": "def find_Min_Sum(lst, lst2, n):\n    # Sort both lists\n    lst.sort()\n    lst2.sort()\n    \n    # Initialize the sum\n    total_sum = 0\n    \n    # Iterate through the elements and calculate the absolute differences\n    for i in range(n):\n        total_sum += abs(lst[i] - lst2[i])\n    \n    return total_sum"
  },
  {
    "id": 57,
    "response": "def first_Digit(n):\n    if n == 0 or n == 1:\n        return 1\n    log_sum = 0.0\n    for i in range(2, n + 1):\n        log_sum += math.log10(i)\n    fractional_part = log_sum - int(log_sum)\n    first_digit = 10 ** fractional_part\n    return int(first_digit)"
  },
  {
    "id": 58,
    "response": "def max_occurrences(lst):\n    if not lst:\n        return None\n    freq = {}\n    for item in lst:\n        freq[item] = freq.get(item, 0) + 1\n    max_count = -1\n    max_item = None\n    for item in lst:\n        if freq[item] > max_count:\n            max_count = freq[item]\n            max_item = item\n        elif freq[item] == max_count and max_item is None:\n            max_item = item\n    return max_item"
  },
  {
    "id": 59,
    "response": "def Repeat(lst):\n    freq = {}\n    for num in lst:\n        if num in freq:\n            freq[num] += 1\n        else:\n            freq[num] = 1\n    duplicates = [num for num in freq if freq[num] > 1]\n    print(' '.join(map(str, duplicates)))"
  },
  {
    "id": 60,
    "response": ""
  },
  {
    "id": 61,
    "response": "def max_sum_of_three_consecutive(lst, n):\n    max_sum = 0\n    for indices in itertools.combinations(range(len(lst)), 3):\n        i, j, k = indices\n        if not (j == i+1 and k == j+1):\n            current_sum = lst[i] + lst[j] + lst[k]\n            if current_sum > max_sum:\n                max_sum = current_sum\n    return max_sum"
  },
  {
    "id": 62,
    "response": "def sorted_dict(dct):\n    return sorted(dct.items())"
  },
  {
    "id": 63,
    "response": ""
  },
  {
    "id": 64,
    "response": "def average_Even(n):\n    # Generate list of even numbers up to n\n    evens = [i for i in range(2, n+1, 2)]\n    if not evens:\n        return 0  # or handle as needed\n    return sum(evens) / len(evens)"
  },
  {
    "id": 65,
    "response": "def move_last(lst):\n    if not lst:\n        return lst\n    return [lst[-1]] + lst[:-1]"
  },
  {
    "id": 66,
    "response": ""
  },
  {
    "id": 67,
    "response": "def Check_Vow(s):\n    vowels = 'aeiouAEIOU'\n    count = 0\n    for char in s:\n        if char in vowels:\n            count +=1\n    return count"
  },
  {
    "id": 68,
    "response": ""
  },
  {
    "id": 69,
    "response": "def check_IP(s):\n    pattern = r'^((25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])\\.){3}(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]|[0-9])$'\n    return bool(re.fullmatch(pattern, s))"
  },
  {
    "id": 70,
    "response": "def decreasing_trend(lst):\n    if len(lst) <= 1:\n        return True\n    for i in range(len(lst) - 1):\n        if lst[i] <= lst[i+1]:\n            return False\n    return True"
  },
  {
    "id": 71,
    "response": ""
  },
  {
    "id": 72,
    "response": "def max_of_three(n, n2, n3):\n    return max(n, n2, n3)"
  },
  {
    "id": 73,
    "response": "def convert(lst):\n    return int(''.join(map(str, lst)))"
  },
  {
    "id": 74,
    "response": "def remove_duplicate(s):\n    words = s.split()\n    seen = set()\n    result = []\n    for word in words:\n        if word not in seen:\n            seen.add(word)\n            result.append(word)\n    return ' '.join(result)"
  },
  {
    "id": 75,
    "response": "def sum_nums(n, n2, n3, n4):\n    total = n + n2\n    if n3 <= total <= n4:\n        return 20\n    else:\n        return total"
  },
  {
    "id": 76,
    "response": "def remove_extra_char(s):\n    return re.sub(r'[^a-zA-Z0-9]', '', s)"
  },
  {
    "id": 77,
    "response": "def validity_triangle(n, n2, n3):\n    # Check if all sides are positive\n    if n <= 0 or n2 <= 0 or n3 <= 0:\n        return False\n    # Sort the sides\n    sides = sorted([n, n2, n3])\n    a, b, c = sides\n    # Check the triangle inequality\n    return a + b > c"
  },
  {
    "id": 78,
    "response": "def remove_spaces(s):\n    return s.replace(' ', '')"
  },
  {
    "id": 79,
    "response": "def access_key(dct, n):\n    return dct.get(n)"
  },
  {
    "id": 80,
    "response": "def increasing_trend(lst):\n    if len(lst) <= 1:\n        return True\n    for i in range(len(lst) - 1):\n        if lst[i] >= lst[i+1]:\n            return False\n    return True"
  },
  {
    "id": 81,
    "response": "def smallest_Divisor(n):\n    if n <= 1:\n        return None  # No divisors greater than 1 for n <= 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return i\n    return n"
  },
  {
    "id": 82,
    "response": "def mul_list(lst, lst2):\n    return list(map(lambda x, y: x * y, lst, lst2))"
  },
  {
    "id": 83,
    "response": "def sum_square(n):\n    if n < 0:\n        return False\n    for a in range(int(n**0.5) + 1):\n        b_squared = n - a*a\n        if b_squared < 0:\n            continue\n        b = int(b_squared**0.5)\n        if b*b == b_squared:\n            return True\n    return False"
  },
  {
    "id": 84,
    "response": ""
  },
  {
    "id": 85,
    "response": "def sum_of_primes(n):\n    if n < 2:\n        return 0\n    is_prime = [True] * (n + 1)\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(n ** 0.5) + 1):\n        if is_prime[i]:\n            for j in range(i * i, n + 1, i):\n                is_prime[j] = False\n    return sum(i for i, prime in enumerate(is_prime) if prime)"
  },
  {
    "id": 86,
    "response": "def freq_element(tup):\n    return dict(Counter(tup))"
  },
  {
    "id": 87,
    "response": "def recur_gcd(n, n2):\n    if n2 == 0:\n        return n\n    else:\n        return recur_gcd(n2, n % n2)"
  },
  {
    "id": 88,
    "response": "def len_complex(n, n2):\n    return math.sqrt(n**2 + n2**2)"
  },
  {
    "id": 89,
    "response": "def min_jumps(lst, n):"
  },
  {
    "id": 90,
    "response": "def mul_consecutive_nums(lst):\n    product = 1\n    for num in lst:\n        product *= num\n    return product"
  },
  {
    "id": 91,
    "response": "def group_element(lst):\n    grouped = {}\n    for item in lst:\n        key = item[1]\n        value = item[0]\n        if key not in grouped:\n            grouped[key] = []\n        grouped[key].append(value)\n    return grouped"
  },
  {
    "id": 92,
    "response": "def last_Two_Digits(n):\n    if n >= 20:\n        return 0\n    result = 1\n    for i in range(1, n+1):\n        result *= i\n    return result % 100"
  },
  {
    "id": 93,
    "response": "def remove_multiple_spaces(s):\n    return re.sub(' +', ' ', s)"
  },
  {
    "id": 94,
    "response": "def extract_unique(dct):\n    unique_values = set()\n    for value in dct.values():\n        unique_values.add(value)\n    return list(unique_values)"
  },
  {
    "id": 95,
    "response": "def check_greater(tup, tup2):\n    if len(tup) != len(tup2):\n        return False\n    for i in range(len(tup)):\n        if tup2[i] <= tup[i]:\n            return False\n    return True"
  },
  {
    "id": 96,
    "response": "def zip_list(lst, lst2):\n    result = []\n    min_len = min(len(lst), len(lst2))\n    for i in range(min_len):\n        result.append((lst[i], lst2[i]))\n    return result"
  },
  {
    "id": 97,
    "response": "def count_even(lst):\n    return len(list(filter(lambda x: x % 2 == 0, lst)))"
  },
  {
    "id": 98,
    "response": "def sort_dict_item(dct):\n    # Compute the product for each key\n    sorted_items = sorted(dct.items(), key=lambda item: math.prod(item[0]))\n    return sorted_items"
  },
  {
    "id": 99,
    "response": "def min_swaps(s, s2):\n    if len(s) != len(s2):\n        return -1\n    count0_s = s.count('0')\n    count1_s = len(s) - count0_s\n    count0_s2 = s2.count('0')\n    count1_s2 = len(s2) - count0_s2\n    if count0_s != count0_s2 or count1_s != count1_s2:\n        return -1\n    diff_count = 0\n    for i in range(len(s)):\n        if s[i] != s2[i]:\n            diff_count +=1\n    return diff_count // 2"
  },
  {
    "id": 100,
    "response": "def count_range_in_list(lst, n, n2):\n    lower = min(n, n2)\n    upper = max(n, n2)\n    count = 0\n    for num in lst:\n        if lower <= num <= upper:\n            count +=1\n    return count"
  },
  {
    "id": 101,
    "response": "def equilibrium_index(lst):\n    total_sum = sum(lst)\n    left_sum = 0\n    for i in range(len(lst)):\n        right_sum = total_sum - left_sum - lst[i]\n        if left_sum == right_sum:\n            return i\n        left_sum += lst[i]\n    return -1"
  },
  {
    "id": 102,
    "response": "def removals(lst, k):\n    if not lst:\n        return 0\n    lst.sort()\n    left = 0\n    max_len = 0\n    for right in range(len(lst)):\n        while lst[right] - lst[left] > k:\n            left +=1\n        current_len = right - left +1\n        if current_len > max_len:\n            max_len = current_len\n    return len(lst) - max_len"
  },
  {
    "id": 103,
    "response": "def is_key_present(dct, n):\n    return n in dct"
  },
  {
    "id": 104,
    "response": "def harmonic_sum(n):\n    if n <= 0:\n        return 0.0\n    total = 0.0\n    for i in range(1, n + 1):\n        total += 1.0 / i\n    return total"
  },
  {
    "id": 105,
    "response": "def sort_sublists(lst):\n    return sorted(lst, key=lambda x: (len(x), x))"
  },
  {
    "id": 106,
    "response": "def is_subset(lst, n, lst2, n2):\n    # Check if all elements in lst are present in lst2\n    # Convert lst2 to a set for O(1) lookups\n    set_lst2 = set(lst2)\n    for i in range(n):\n        if lst[i] not in set_lst2:\n            return False\n    return True"
  },
  {
    "id": 107,
    "response": "def count_Set_Bits(n):\n    total = 0\n    for i in range(1, n + 1):\n        total += bin(i).count('1')\n    return total"
  },
  {
    "id": 108,
    "response": "def Convert(s):\n    return list(s)"
  },
  {
    "id": 109,
    "response": "def get_unique(lst):\n    return len(set(lst))"
  },
  {
    "id": 110,
    "response": "def front_and_rear(tup):\n    if not tup:\n        return None\n    return (tup[0], tup[-1])"
  },
  {
    "id": 111,
    "response": "def product_Equal(n):\n    digits = [int(d) for d in str(n)]\n    product = 1\n    for d in digits:\n        product *= d\n    sum_digits = sum(digits)\n    return product % 2 == 0 and product == sum_digits"
  },
  {
    "id": 112,
    "response": "def remove_duplicate(lst):\n    seen = set()\n    result = []\n    for item in lst:\n        if item not in seen:\n            seen.add(item)\n            result.append(item)\n    return result"
  },
  {
    "id": 113,
    "response": "def check_valid(tup):\n    for element in tup:\n        if not isinstance(element, int):\n            return False\n    return True"
  },
  {
    "id": 114,
    "response": "def count_Fac(n):\n    if n == 1:\n        return 0\n    factors = set()\n    i = 2\n    while i * i <= n:\n        if n % i == 0:\n            factors.add(i)\n            while n % i == 0:\n                n = n // i\n        i += 1\n    if n > 1:\n        factors.add(n)\n    return len(factors)"
  },
  {
    "id": 115,
    "response": "def str_to_tuple(s):\n    parts = s.split(',')\n    return tuple(int(part.strip()) for part in parts)"
  },
  {
    "id": 116,
    "response": "def rombus_perimeter(n):\n    return 4 * n"
  },
  {
    "id": 117,
    "response": "def sd_calc(lst):\n    if len(lst) <= 1:\n        return 0\n    mean = sum(lst) / len(lst)\n    squared_diffs = [(x - mean) ** 2 for x in lst]\n    variance = sum(squared_diffs) / len(lst)\n    return math.sqrt(variance)"
  },
  {
    "id": 118,
    "response": "def alternate_elements(lst):\n    return [lst[i] for i in range(len(lst)) if i % 2 == 0]"
  },
  {
    "id": 119,
    "response": ""
  },
  {
    "id": 120,
    "response": "def add_dict_to_tuple(tup, dct):\n    # Convert the tuple to a list\n    new_list = list(tup)\n    # Append the dictionary to the list\n    new_list.append(dct)\n    # Convert the list back to a tuple\n    return tuple(new_list)"
  },
  {
    "id": 121,
    "response": "def maxAverageOfPath(lst, n):\n    # Initialize dp table\n    dp = [[0]*n for _ in range(n)]\n    dp[0][0] = lst[0][0]\n    for i in range(n):\n        for j in range(n):\n            if i == 0 and j == 0:\n                continue\n            elif i == 0:\n                dp[i][j] = dp[i][j-1] + lst[i][j]\n            elif j == 0:\n                dp[i][j] = dp[i-1][j] + lst[i][j]\n            else:\n                dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + lst[i][j]\n    max_sum = dp[n-1][n-1]\n    steps = 2 * n - 2\n    return max_sum / steps"
  },
  {
    "id": 122,
    "response": "def filter_data(dct, n, n2):\n    filtered = {}\n    for key, value in dct.items():\n        if value[0] >= n and value[1] >= n2:\n            filtered[key] = value\n    return filtered"
  },
  {
    "id": 123,
    "response": "def count_same_pair(lst, lst2):\n    count = 0\n    for i in range(min(len(lst), len(lst2))):\n        if lst[i] == lst2[i]:\n            count += 1\n    return count"
  },
  {
    "id": 124,
    "response": "def power_base_sum(n, n2):\n    result = n ** n2\n    return sum(int(digit) for digit in str(result))"
  },
  {
    "id": 125,
    "response": "def extract_quotation(s):\n    # Use regular expression to find all quoted strings\n    # The pattern matches both single and double quotes, and captures the content inside\n    matches = re.findall(r'[\"\\']([^\"\\']*)[\"\\']', s)\n    return matches"
  },
  {
    "id": 126,
    "response": "def multiply_elements(tup): ... Then, product = 1, for num in tup: product *= num, return product."
  },
  {
    "id": 127,
    "response": "def remove_char(s):\n    import re\n    return re.sub(r'[^a-zA-Z]', '', s)"
  },
  {
    "id": 128,
    "response": "def sum_list(lst, lst2):\n    if len(lst) != len(lst2):\n        return []\n    result = []\n    for i in range(len(lst)):\n        result.append(lst[i] + lst2[i])\n    return result"
  },
  {
    "id": 129,
    "response": "def add_list(lst, lst2):\n    return list(map(lambda x, y: x + y, lst, lst2))"
  },
  {
    "id": 130,
    "response": "def consecutive_duplicates(lst):\n    if not lst:\n        return []\n    result = [lst[0]]\n    for item in lst[1:]:\n        if item != result[-1]:\n            result.append(item)\n    return result"
  },
  {
    "id": 131,
    "response": "def lateralsurface_cone(r, h): ... So the parameters are radius and height. Therefore, the code would be:"
  },
  {
    "id": 132,
    "response": "def replace_specialchar(s):\n    return s.replace(' ', ':').replace(',', ':').replace('.', ':')"
  },
  {
    "id": 133,
    "response": "def find_first_occurrence(lst, n):\n    for i in range(len(lst)):\n        if lst[i] == n:\n            return i\n    return -1"
  },
  {
    "id": 134,
    "response": "def sum_Of_Subarray_Prod(lst, n):\n    # code here"
  },
  {
    "id": 135,
    "response": ""
  },
  {
    "id": 136,
    "response": "def left_insertion(lst, n):\n    for i in range(len(lst)):\n        if lst[i] >= n:\n            return i\n    return len(lst)"
  },
  {
    "id": 137,
    "response": "def check_str(s):\n    if not s:\n        return False\n    vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n    return s[0] in vowels"
  },
  {
    "id": 138,
    "response": "def geometric_sum(n):\n    if n == 0:\n        return 0\n    return 2 * (1 - (1/2)**(n-1))"
  },
  {
    "id": 139,
    "response": ""
  },
  {
    "id": 140,
    "response": "def tuple_to_dict(tup):\n    d = {}\n    for i in range(0, len(tup), 2):\n        if i + 1 < len(tup):\n            d[tup[i]] = tup[i+1]\n    return d"
  },
  {
    "id": 141,
    "response": "def all_Characters_Same(s):\n    if not s:\n        return True\n    first_char = s[0]\n    for char in s:\n        if char != first_char:\n            return False\n    return True"
  },
  {
    "id": 142,
    "response": "def area_tetrahedron(n):\n    return math.sqrt(3) * n ** 2"
  },
  {
    "id": 143,
    "response": "def rotate_right(lst, n, n2):\n    if not lst:\n        return lst\n    total_rotation = (n + n2) % len(lst)\n    return lst[-total_rotation:] + lst[:-total_rotation]"
  },
  {
    "id": 144,
    "response": "def check_none(tup):\n    return any(element is None for element in tup)"
  },
  {
    "id": 145,
    "response": "def divisible_by_digits(n, n2):"
  },
  {
    "id": 146,
    "response": "def sector_area(n, n2):\n    return (n2 * n ** 2) / 2"
  },
  {
    "id": 147,
    "response": "def lcs_of_three(s, s2, s3, n, n2, n3):\n    # Initialize a 3D array with zeros\n    dp = [[[0]*(n3+1) for _ in range(n2+1)] for _ in range(n+1)]\n    \n    # Fill the dp table\n    for i in range(1, n+1):\n        for j in range(1, n2+1):\n            for k in range(1, n3+1):\n                if s[i-1] == s2[j-1] == s3[k-1]:\n                    dp[i][j][k] = 1 + dp[i-1][j-1][k-1]\n                else:\n                    dp[i][j][k] = max(dp[i-1][j][k], dp[i][j-1][k], dp[i][j][k-1])\n    \n    return dp[n][n2][n3]"
  },
  {
    "id": 148,
    "response": "def capital_words_spaces(s):\n    words = re.findall(r'[A-Z][a-z]*', s)\n    return ' '.join(words)"
  },
  {
    "id": 149,
    "response": "def sort_numeric_strings(lst):\n    return sorted(lst, key=lambda x: int(x))"
  },
  {
    "id": 150,
    "response": "def add_tuple(lst, tup):\n    lst.extend(tup)\n    return lst"
  },
  {
    "id": 151,
    "response": "def check_min_heap(lst, n):\n    for i in range((n - 2) // 2 + 1):\n        left = 2 * i + 1\n        right = 2 * i + 2\n        if left < n and lst[i] > lst[left]:\n            return False\n        if right < n and lst[i] > lst[right]:\n            return False\n    return True"
  },
  {
    "id": 152,
    "response": "def jacobsthal_num(n):\n    return (2**n - (-1)**n) // 3"
  },
  {
    "id": 153,
    "response": "def min_k(lst, n):\n    sorted_lst = sorted(lst)\n    return sorted_lst[:n]"
  },
  {
    "id": 154,
    "response": "def extract_index_list(lst, lst2, lst3):\n    indices = []\n    min_len = min(len(lst), len(lst2), len(lst3))\n    for i in range(min_len):\n        if lst[i] == lst2[i] == lst3[i]:\n            indices.append(i)\n    return indices"
  },
  {
    "id": 155,
    "response": "def second_smallest(lst):\n    # sort the list\n    sorted_lst = sorted(lst)\n    # find the first element greater than the first element\n    first = sorted_lst[0]\n    for num in sorted_lst:\n        if num > first:\n            return num\n    # if all elements are the same\n    return first"
  },
  {
    "id": 156,
    "response": "def text_match_zero_one(s):\n    return '0' in s or 'b' in s"
  },
  {
    "id": 157,
    "response": "def count_reverse_pairs(lst):\n    seen = set()\n    count = 0\n    for s in lst:\n        rev = s[::-1]\n        if rev in seen:\n            count +=1\n            seen.remove(rev)\n        else:\n            seen.add(s)\n    return count"
  },
  {
    "id": 158,
    "response": "def unique_sublists(lst):\n    sublists = set()\n    n = len(lst)\n    for i in range(n):\n        for j in range(i, n):\n            sublists.add(tuple(lst[i:j+1]))\n    return len(sublists)"
  },
  {
    "id": 159,
    "response": ""
  },
  {
    "id": 160,
    "response": "def unique_Element(lst, n):\n    if n == 0:\n        return False\n    freq = {}\n    for i in range(n):\n        freq[lst[i]] = freq.get(lst[i], 0) + 1\n    count = 0\n    for val in freq.values():\n        if val == 1:\n            count += 1\n    return count == 1"
  },
  {
    "id": 161,
    "response": "def arc_length(n, n2):\n    return n * n2"
  },
  {
    "id": 162,
    "response": "def check_monthnumber_number(n):\n    # Months with 30 days are April (4), June (6), September (9), November (11)\n    return n in {4, 6, 9, 11}"
  },
  {
    "id": 163,
    "response": "def find_Min_Diff(tup, n):\n    if n < 2:\n        return 0\n    sorted_tup = sorted(tup)\n    min_diff = float('inf')\n    for i in range(n - 1):\n        diff = abs(sorted_tup[i] - sorted_tup[i + 1])\n        if diff < min_diff:\n            min_diff = diff\n    return min_diff"
  },
  {
    "id": 164,
    "response": "def number_ctr(s):\n    count = 0\n    for char in s:\n        if char.isdigit():\n            count +=1\n    return count"
  },
  {
    "id": 165,
    "response": "def is_polite(n):\n    if n <= 1:\n        return False\n    # Check if n is a power of two\n    return (n & (n - 1)) != 0"
  },
  {
    "id": 166,
    "response": "def pair_wise(lst):\n    result = []\n    for i in range(len(lst) - 1):\n        result.append( (lst[i], lst[i+1]) )\n    return result"
  },
  {
    "id": 167,
    "response": "def get_Pairs_Count(lst, n, n2):\n    target = n + n2\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if lst[i] + lst[j] == target:\n                count +=1\n    return count"
  },
  {
    "id": 168,
    "response": "def check_Odd_Parity(n):\n    return n % 2 == 1"
  },
  {
    "id": 169,
    "response": "def Diff(lst, lst2):\n    return [x for x in lst if x not in lst2]"
  },
  {
    "id": 170,
    "response": "def odd_Num_Sum(n):\n    total = 0\n    for i in range(1, n+1):\n        num = 2*i -1\n        total += num **4\n    return total"
  },
  {
    "id": 171,
    "response": "def check_expression(s):\n    stack = []\n    for char in s:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if not stack:\n                return False\n            stack.pop()\n    return len(stack) == 0"
  },
  {
    "id": 172,
    "response": "def remove_length(s, n):\n    words = s.split()\n    filtered = [word for word in words if len(word) != n]\n    return ' '.join(filtered)"
  },
  {
    "id": 173,
    "response": "def occurrence_substring(s, s2):\n    result = []\n    len_s = len(s)\n    len_s2 = len(s2)\n    if len_s2 == 0 or len_s2 > len_s:\n        return result\n    for i in range(len_s - len_s2 + 1):\n        if s[i:i+len_s2] == s2:\n            result.append(i)\n    return result"
  },
  {
    "id": 174,
    "response": "def check_email(s):\n    if not s or '@' not in s:\n        return False\n    parts = s.split('@')\n    if len(parts) != 2:\n        return False\n    local_part, domain_part = parts[0], parts[1]\n    \n    # Validate local part\n    if not local_part:\n        return False\n    if local_part[0] == '.' or local_part[-1] == '.':\n        return False\n    if '..' in local_part:\n        return False\n    if ' ' in local_part:\n        return False\n    for char in local_part:\n        if not (char.isalnum() or char in ['.', '_', '-']):\n            return False\n    \n    # Validate domain part\n    if not domain_part:\n        return False\n    if domain_part[0] == '-' or domain_part[-1] == '-':\n        return False\n    if '.' not in domain_part:\n        return False\n    if ' ' in domain_part:\n        return False\n    \n    # Split domain into subdomains\n    subdomains = domain_part.split('.')\n    if len(subdomains) < 2:\n        return False\n    for subdomain in subdomains:\n        if not subdomain:\n            return False\n        if subdomain[0] == '-' or subdomain[-1] == '-':\n            return False\n    \n    # Check TLD length\n    tld = subdomains[-1]\n    if len(tld) < 2:\n        return False\n    \n    return True"
  },
  {
    "id": 175,
    "response": "def odd_position(lst):\n    for i in range(len(lst)):\n        if i % 2 == 1:  # if index is odd\n            if lst[i] % 2 == 0:\n                return False\n    return True"
  },
  {
    "id": 176,
    "response": "def count_vowels(s):\n    vowels = {'a', 'e', 'i', 'o', 'u'}\n    count = 0\n    for char in s.lower():\n        if char in vowels:\n            count +=1\n    return count"
  },
  {
    "id": 177,
    "response": "def find_Sum(lst, n):\n    seen = set()\n    unique_elements = []\n    for element in lst:\n        if element not in seen:\n            seen.add(element)\n            unique_elements.append(element)\n            if len(unique_elements) == n:\n                break\n    return sum(unique_elements)"
  },
  {
    "id": 178,
    "response": "def pack_consecutive_duplicates(lst):\n    if not lst:\n        return []\n    result = []\n    current_group = [lst[0]]\n    for element in lst[1:]:\n        if element == current_group[-1]:\n            current_group.append(element)\n        else:\n            result.append(current_group)\n            current_group = [element]\n    result.append(current_group)\n    return result"
  },
  {
    "id": 179,
    "response": "def unique_sublists(lst):\n    sublists = set()\n    n = len(lst)\n    for i in range(n):\n        for j in range(i, n):\n            sublists.add(tuple(lst[i:j+1]))\n    return len(sublists)"
  },
  {
    "id": 180,
    "response": "def find_combinations(lst):\n    return list(itertools.product(*lst))"
  },
  {
    "id": 181,
    "response": "def count_Divisors(n):\n    if n == 0:\n        return 'even'  # but 0 has infinite divisors, but maybe the function is for positive integers.\n    count = 0\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            if i == n // i:\n                count += 1\n            else:\n                count += 2\n    if count % 2 == 0:\n        return 'even'\n    else:\n        return 'odd'"
  },
  {
    "id": 182,
    "response": "def Odd_Length_Sum(lst):\n    n = len(lst)\n    if n == 0:\n        return 0\n    prefix = [0] * (n + 1)\n    for i in range(n):\n        prefix[i+1] = prefix[i] + lst[i]\n    total = 0\n    for start in range(n):\n        for end in range(start, n):\n            length = end - start + 1\n            if length % 2 == 1:\n                total += prefix[end+1] - prefix[start]\n    return total"
  },
  {
    "id": 183,
    "response": "def rgb_to_hsv(r, g, b):\n    r /= 255.0\n    g /= 255.0\n    b /= 255.0\n    max_c = max(r, g, b)\n    min_c = min(r, g, b)\n    delta = max_c - min_c\n    if max_c == 0:\n        h = 0\n        s = 0\n    else:\n        s = (delta / max_c) * 100\n        if delta == 0:\n            h = 0\n        else:\n            if max_c == r:\n                h = ((g - b) / delta) % 6\n            elif max_c == g:\n                h = ((b - r) / delta) % 6 + 2\n            else:  # max_c == b\n                h = ((r - g) / delta) % 6 + 4\n            h *= 60\n            if h < 0:\n                h += 360\n    v = max_c * 100\n    return (h, s, v)"
  },
  {
    "id": 184,
    "response": "def mul_even_odd(lst):\n    first_even = None\n    first_odd = None\n    for num in lst:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        if first_odd is None and num % 2 != 0:\n            first_odd = num\n        # Once both are found, can break early?\n        if first_even is not None and first_odd is not None:\n            break\n    if first_even is not None and first_odd is not None:\n        return first_even * first_odd\n    else:\n        return 0"
  },
  {
    "id": 185,
    "response": "def tuple_str_int(s):\n    return tuple(int(item) for item in s)"
  },
  {
    "id": 186,
    "response": "def right_insertion(lst, n):\n    return bisect.bisect_right(lst, n)"
  },
  {
    "id": 187,
    "response": "def text_match_three(s):\n    return 'abbb' in s"
  },
  {
    "id": 188,
    "response": "def new_tuple(lst, s):\n    return (s,) + tuple(lst)"
  },
  {
    "id": 189,
    "response": "def perimeter_polygon(n, side_length):\n    return n * side_length"
  },
  {
    "id": 190,
    "response": "def even_position(lst):\n    for i in range(len(lst)):\n        if i % 2 == 0:\n            if lst[i] % 2 != 0:\n                return False\n    return True"
  },
  {
    "id": 191,
    "response": "def flatten(element):\n    if not isinstance(element, tuple):\n        return [element]\n    else:\n        result = []\n        for sub in element:\n            result.extend(flatten(sub))\n        return result"
  },
  {
    "id": 192,
    "response": "def count_list(lst):\n    return len(lst)"
  },
  {
    "id": 193,
    "response": "def last(lst, x):\n    low = 0\n    high = len(lst) - 1\n    result = -1\n    while low <= high:\n        mid = (low + high) // 2\n        if lst[mid] == x:\n            result = mid\n            low = mid + 1\n        elif lst[mid] < x:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return result"
  },
  {
    "id": 194,
    "response": "def check_string(s):\n    if not s or s[-1] != 'b':\n        return False\n    return 'a' in s[:-1]"
  },
  {
    "id": 195,
    "response": "def cheap_items(lst, n):\n    if not lst or n <= 0:\n        return []\n    # Sort the list by price\n    sorted_lst = sorted(lst, key=lambda x: x['price'])\n    # Take the first n items\n    return sorted_lst[:n]"
  },
  {
    "id": 196,
    "response": "def return_sum(dct):\n    return sum(dct.values())"
  },
  {
    "id": 197,
    "response": "def sum_in_Range(n, n2):\n    l = min(n, n2)\n    r = max(n, n2)\n    # Find first odd >= l\n    if l % 2 == 0:\n        first_odd = l + 1\n    else:\n        first_odd = l\n    # Find last odd <= r\n    if r % 2 == 0:\n        last_odd = r - 1\n    else:\n        last_odd = r\n    # Check if there are any odd numbers in the range\n    if first_odd > r or last_odd < l:\n        return 0\n    # Calculate number of terms\n    num_terms = ((last_odd - first_odd) // 2) + 1\n    # Sum of arithmetic series\n    total = num_terms * (first_odd + last_odd) // 2\n    return total"
  },
  {
    "id": 198,
    "response": "def _sum(lst):\n    total = 0\n    for num in lst:\n        total += num\n    return total"
  },
  {
    "id": 199,
    "response": ""
  },
  {
    "id": 200,
    "response": "def remove_all_spaces(s):\n    result = ''\n    for char in s:\n        if not char.isspace():\n            result += char\n    return result"
  },
  {
    "id": 201,
    "response": "def test_three_equal(n, n2, n3):\n    if n == n2 and n == n3:\n        return 3\n    elif n == n2 or n == n3 or n2 == n3:\n        return 2\n    else:\n        return 0"
  },
  {
    "id": 202,
    "response": "def count_Rotation(lst, n):\n    # find the index of the minimum element\n    min_val = min(lst)\n    min_index = lst.index(min_val)\n    return min_index"
  },
  {
    "id": 203,
    "response": "def is_Perfect_Square(n):\n    if n < 0:\n        return False\n    root = int(math.isqrt(n))  # Using math.isqrt for Python 3.8+ which returns the integer square root\n    return root * root == n"
  },
  {
    "id": 204,
    "response": "def is_Product_Even(lst, n):\n    if len(lst) < n:\n        return False\n    # Check if any of the first n elements is even\n    for i in range(n):\n        if lst[i] % 2 == 0:\n            return True\n    return False"
  },
  {
    "id": 205,
    "response": "def max_sum_list(lst):\n    if not lst:\n        return []\n    max_sum = current_sum = lst[0]\n    start = end = 0\n    for i in range(1, len(lst)):\n        if current_sum + lst[i] > lst[i]:\n            current_sum += lst[i]\n        else:\n            current_sum = lst[i]\n            start = i\n        if current_sum > max_sum:\n            max_sum = current_sum\n            end = i\n    return lst[start:end+1]"
  },
  {
    "id": 206,
    "response": "def max_run_uppercase(s):\n    max_count = 0\n    current_count = 0\n    for char in s:\n        if char.isupper():\n            current_count += 1\n            if current_count > max_count:\n                max_count = current_count\n        else:\n            current_count = 0\n    return max_count"
  },
  {
    "id": 207,
    "response": "def first_odd(lst):\n    for num in lst:\n        if num % 2 != 0:\n            return num\n    return None"
  },
  {
    "id": 208,
    "response": "def check_K(tup, n):\n    return n in tup"
  },
  {
    "id": 209,
    "response": "def check_smaller(tup, tup2):\n    if len(tup) != len(tup2):\n        return False\n    for i in range(len(tup)):\n        if tup2[i] >= tup[i]:\n            return False\n    return True"
  },
  {
    "id": 210,
    "response": "def count_variable(*args): ... Then, we can use a dictionary to count the occurrences. For each argument in args, we increment the count in the dictionary."
  },
  {
    "id": 211,
    "response": "def check_identical(lst, lst2):\n    return lst == lst2"
  },
  {
    "id": 212,
    "response": "def road_rd(s):\n    return s.replace('road', 'rd.')"
  },
  {
    "id": 213,
    "response": "def string_length(s):\n    return len(s)"
  },
  {
    "id": 214,
    "response": "def rombus_area(n, n2):\n    return (n * n2) / 2"
  },
  {
    "id": 215,
    "response": "def sort_by_dnf(lst, n):\n    low = 0\n    mid = 0\n    high = n - 1\n    while mid <= high:\n        if lst[mid] == 0:\n            lst[low], lst[mid] = lst[mid], lst[low]\n            low += 1\n            mid += 1\n        elif lst[mid] == 1:\n            mid += 1\n        else:\n            lst[mid], lst[high] = lst[high], lst[mid]\n            high -= 1\n    return lst"
  },
  {
    "id": 216,
    "response": "def clear_tuple(tup):\n    seen = set()\n    result = []\n    for item in tup:\n        if item not in seen:\n            seen.add(item)\n            result.append(item)\n    return tuple(result)"
  },
  {
    "id": 217,
    "response": "def div_of_nums(lst, n, n2):\n    return list(filter(lambda x: x % n == 0 or x % n2 == 0, lst))"
  },
  {
    "id": 218,
    "response": "def lower_ctr(s):\n    count = 0\n    for char in s:\n        if char.islower():\n            count +=1\n    return count"
  },
  {
    "id": 219,
    "response": "def count_duplic(lst):"
  },
  {
    "id": 220,
    "response": "def check_monthnum_number(n):\n    if not isinstance(n, int) or n < 1 or n > 12:\n        return False\n    return n == 2"
  },
  {
    "id": 221,
    "response": "def merge_dictionaries(dct, dct2):\n    merged = dct.copy()\n    merged.update(dct2)\n    return merged"
  },
  {
    "id": 222,
    "response": "def pass_validity(s):\n    if len(s) < 8:\n        return False\n    has_upper = any(c.isupper() for c in s)\n    has_lower = any(c.islower() for c in s)\n    has_digit = any(c.isdigit() for c in s)\n    has_space = any(c.isspace() for c in s)\n    return has_upper and has_lower and has_digit and not has_space"
  },
  {
    "id": 223,
    "response": "def check_substring(s, s2):\n    pattern = re.escape(s2)\n    return bool(re.match(pattern, s))"
  },
  {
    "id": 224,
    "response": "def remove_even(lst):\n    return [x for x in lst if x % 2 != 0]"
  },
  {
    "id": 225,
    "response": "def access_elements(lst, lst2):\n    return [lst[i] for i in lst2]"
  },
  {
    "id": 226,
    "response": "def check_Type_Of_Triangle(n, n2, n3):\n    # Check if the sides form a valid triangle\n    if n + n2 <= n3 or n + n3 <= n2 or n2 + n3 <= n:\n        return 'Not a triangle'\n    # Check for equilateral triangle\n    if n == n2 == n3:\n        return 'Equilateral'\n    # Check for isosceles triangle (at least two sides equal)\n    elif n == n2 or n == n3 or n2 == n3:\n        return 'Isosceles'\n    # Otherwise, it's a scalene triangle\n    else:\n        return 'Scalene'"
  },
  {
    "id": 227,
    "response": "def sum_column(lst, n):\n    total = 0\n    for row in lst:\n        total += row[n]\n    return total"
  },
  {
    "id": 228,
    "response": "def count_alpha_dig_spl(s):\n    alpha = 0\n    dig = 0\n    spl = 0\n    for char in s:\n        if char.isalpha():\n            alpha +=1\n        elif char.isdigit():\n            dig +=1\n        else:\n            spl +=1\n    return alpha, dig, spl"
  },
  {
    "id": 229,
    "response": "def second_frequent(lst):\n    counts = Counter(lst)\n    sorted_counts = sorted(counts.items(), key=lambda x: (-x[1], x[0]))\n    max_count = sorted_counts[0][1]\n    for count, element in sorted_counts:\n        if count < max_count:\n            return element\n    return None  # if all elements have the same count"
  },
  {
    "id": 230,
    "response": "def round_up(n, n2):\n    if n2 == 0:\n        raise ValueError(\"n2 cannot be zero\")\n    return ((n + n2 - 1) // n2) * n2"
  },
  {
    "id": 231,
    "response": "def count_Pairs(lst, n):\n    count = lst.count(n)\n    return count * (count - 1) // 2"
  },
  {
    "id": 232,
    "response": "def extract_max(s):\n    # Find all sequences of digits in the string\n    numbers = re.findall(r'\\d+', s)\n    if not numbers:\n        return None\n    # Convert each to integer and find the maximum\n    max_num = max(int(num) for num in numbers)\n    return max_num"
  },
  {
    "id": 233,
    "response": "def get_key(dct):\n    return list(dct.keys())"
  },
  {
    "id": 234,
    "response": ""
  },
  {
    "id": 235,
    "response": "def slope(n, n2, n3, n4):\n    # Calculate the slope between two points (n, n2) and (n3, n4)\n    numerator = n4 - n2\n    denominator = n3 - n\n    if denominator == 0:\n        return \"undefined\"\n    return numerator / denominator"
  },
  {
    "id": 236,
    "response": ""
  },
  {
    "id": 237,
    "response": "def cube_sum(n):\n    return n**2 * (2 * n**2 - 1)"
  },
  {
    "id": 238,
    "response": "def min_Swaps(s, s2):\n    if len(s) != len(s2):\n        return -1\n    count0 = s.count('0')\n    count1 = len(s) - count0\n    count0_2 = s2.count('0')\n    count1_2 = len(s2) - count0_2\n    if count0 != count0_2 or count1 != count1_2:\n        return -1\n    diff_count = 0\n    for i in range(len(s)):\n        if s[i] != s2[i]:\n            diff_count +=1\n    return diff_count // 2"
  },
  {
    "id": 239,
    "response": "def sort_tuple(lst):\n    return sorted(lst, key=lambda x: x[0])"
  },
  {
    "id": 240,
    "response": "def Check_Solution(n, n2, n3):\n    if n2 != 0:\n        return False\n    # Check if c/a is negative\n    # But need to handle division by zero? Wait, n is a, which can't be zero.\n    # So n is non-zero.\n    product = n3 / n\n    return product < 0"
  },
  {
    "id": 241,
    "response": "def get_inv_count(lst, n):\n    if n <= 1:\n        return 0\n    mid = n // 2\n    left = lst[:mid]\n    right = lst[mid:]\n    inv_left = get_inv_count(left, mid)\n    inv_right = get_inv_count(right, n - mid)\n    inv_merge = 0\n    i = j = k = 0\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            lst[k] = left[i]\n            i += 1\n        else:\n            lst[k] = right[j]\n            j += 1\n            inv_merge += len(left) - i\n        k += 1\n    while i < len(left):\n        lst[k] = left[i]\n        i += 1\n        k += 1\n    while j < len(right):\n        lst[k] = right[j]\n        j += 1\n        k += 1\n    return inv_left + inv_right + inv_merge"
  },
  {
    "id": 242,
    "response": "def get_odd_occurence(lst, n):\n    result = 0\n    for num in lst:\n        result ^= num\n    return result"
  },
  {
    "id": 243,
    "response": "def nth_super_ugly_number(n, lst):\n    heap = [1]\n    seen = {1}\n    while n > 0:\n        current = heapq.heappop(heap)\n        for prime in lst:\n            new_num = current * prime\n            if new_num not in seen:\n                seen.add(new_num)\n                heapq.heappush(heap, new_num)\n        n -= 1\n    return current"
  },
  {
    "id": 244,
    "response": ""
  },
  {
    "id": 245,
    "response": "def find_Digits(n):\n    if n == 0:\n        return 1\n    total = 0\n    for i in range(1, n+1):\n        total += math.log10(i)\n    return int(total // 1) + 1"
  },
  {
    "id": 246,
    "response": "def find_platform(lst, lst2, n):\n    # Sort the arrival and departure times\n    lst.sort()\n    lst2.sort()\n    \n    i = 0  # Pointer for arrival times\n    j = 0  # Pointer for departure times\n    platforms = 0\n    max_platforms = 0\n    \n    while i < n:\n        if lst[i] < lst2[j]:\n            # A new train arrives before the previous one departs\n            platforms += 1\n            max_platforms = max(max_platforms, platforms)\n            i += 1\n        else:\n            # A train has departed, so we can reuse the platform\n            platforms -= 1\n            j += 1\n    \n    return max_platforms"
  },
  {
    "id": 247,
    "response": "def lcopy(lst):\n    if len(lst) == 1:\n        return list(lst)\n    else:\n        # handle error or return empty list\n        return []"
  },
  {
    "id": 248,
    "response": "def area_trapezium(n, n2, n3):\n    return (n + n2) * n3 / 2"
  },
  {
    "id": 249,
    "response": "def Sum(n):\n    total = 0\n    for i in range(1, n+1):\n        if n % i == 0:\n            total += i\n    return total"
  },
  {
    "id": 250,
    "response": "def is_triangleexists(n, n2, n3):\n    # Check if all sides are positive\n    if n <= 0 or n2 <= 0 or n3 <= 0:\n        return False\n    # Check triangle inequality theorem\n    return (n + n2 > n3) and (n + n3 > n2) and (n2 + n3 > n)"
  },
  {
    "id": 251,
    "response": "def Sum_of_Inverse_Divisors(n):\n    total = 0.0\n    for d in range(1, n+1):\n        if n % d == 0:\n            total += 1.0 / d\n    return total"
  },
  {
    "id": 252,
    "response": "def remove_negs(lst):\n    return [x for x in lst if x >= 0]"
  },
  {
    "id": 253,
    "response": "def sum_of_odd_factors(n):\n    # Step 1: Remove factors of 2\n    m = n\n    while m % 2 == 0:\n        m = m // 2"
  },
  {
    "id": 254,
    "response": "def raw_heap(lst):\n    heapq.heapify(lst)\n    return lst"
  },
  {
    "id": 255,
    "response": "def check_Even_Parity(n):\n    count = bin(n).count('1')\n    return count % 2 == 0"
  },
  {
    "id": 256,
    "response": "def find_Min_Swaps(lst, n):\n    count_ones = 0\n    swaps = 0\n    for i in range(n):\n        if lst[i] == 1:\n            count_ones += 1\n        else:\n            swaps += count_ones\n    return swaps"
  },
  {
    "id": 257,
    "response": "def listify_list(lst):\n    result = []\n    for string in lst:\n        for char in string:\n            result.append(char)\n    return result"
  },
  {
    "id": 258,
    "response": "def count_list(lst):\n    from collections import Counter\n    counts = Counter(lst)\n    return [counts[x] ** 2 for x in lst]"
  },
  {
    "id": 259,
    "response": "def sub_lists(lst):\n    result = []\n    n = len(lst)\n    for i in range(n + 1):\n        for j in range(i + 1, n + 1):\n            result.append(lst[i:j])\n    return result"
  },
  {
    "id": 260,
    "response": "def check_alphanumeric(s):\n    if not s:\n        return False\n    return s[-1].isalnum()"
  },
  {
    "id": 261,
    "response": "def anagram_lambda(lst, s):\n    sorted_s = sorted(s)\n    return list(filter(lambda x: sorted(x) == sorted_s, lst))"
  },
  {
    "id": 262,
    "response": "def n_common_words(s, n):\n    if not s or n <= 0:\n        return []\n    words = re.findall(r'\\w+', s.lower())\n    counts = Counter(words)\n    sorted_words = sorted(counts.items(), key=lambda x: (-x[1], x[0]))\n    return [word for word, _ in sorted_words[:n]]"
  },
  {
    "id": 263,
    "response": "def find_longest_conseq_subseq(lst, n):\n    # code here"
  },
  {
    "id": 264,
    "response": "def palindrome_lambda(lst):\n    return list(filter(lambda s: s == s[::-1], lst))"
  },
  {
    "id": 265,
    "response": "def ntimes_list(lst, n):\n    for _ in range(n):\n        print(lst)"
  },
  {
    "id": 266,
    "response": "def check_monthnumb(s):\n    return s in {\"January\", \"March\", \"May\", \"July\", \"August\", \"October\", \"December\"}"
  },
  {
    "id": 267,
    "response": ""
  },
  {
    "id": 268,
    "response": "def length_Of_Last_Word(s):\n    words = s.split()\n    if not words:\n        return 0\n    return len(words[-1])"
  },
  {
    "id": 269,
    "response": "def remove_list_range(lst, n, n2):\n    lower = min(n, n2)\n    upper = max(n, n2)\n    return [x for x in lst if lower <= x <= upper]"
  },
  {
    "id": 270,
    "response": "def sum_positivenum(lst):\n    return sum(filter(lambda x: x > 0, lst))"
  },
  {
    "id": 271,
    "response": "def are_Rotations(s, s2):\n    if len(s) != len(s2):\n        return False\n    if len(s) == 0:\n        return True\n    return s2 in s + s"
  },
  {
    "id": 272,
    "response": "def check_subset(lst, lst2):\n    if not lst2:\n        return True\n    for element in lst:\n        if isinstance(element, list):\n            if check_subset(element, lst2):\n                return True\n        else:\n            if element == lst2[0]:\n                return check_subset(lst, lst2[1:])\n    return False"
  },
  {
    "id": 273,
    "response": "def fibonacci(n):\n    if n <= 0:\n        return []\n    elif n == 1:\n        return [0]\n    elif n == 2:\n        return [0, 1]\n    fib_seq = [0, 1]\n    for i in range(2, n):\n        next_num = fib_seq[-1] + fib_seq[-2]\n        fib_seq.append(next_num)\n    return fib_seq"
  },
  {
    "id": 274,
    "response": "def check_Concat(s, s2):\n    if not s2:\n        return s == \"\"\n    if len(s) % len(s2) != 0:\n        return False\n    return s == s2 * (len(s) // len(s2))"
  },
  {
    "id": 275,
    "response": "def min_difference(lst):\n    # Flatten the list of tuples\n    flat_list = []\n    for t in lst:\n        flat_list.extend(t)\n    # Sort the flat list\n    flat_list.sort()\n    # Find the minimum difference between consecutive elements\n    min_diff = float('inf')\n    for i in range(1, len(flat_list)):\n        diff = flat_list[i] - flat_list[i-1]\n        if diff < min_diff:\n            min_diff = diff\n    return min_diff"
  },
  {
    "id": 276,
    "response": "def lcm(n1, n2):\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a"
  },
  {
    "id": 277,
    "response": "def sort_String(s):\n    words = s.split()\n    words.sort(key=lambda x: x.lower())\n    return ' '.join(words)"
  },
  {
    "id": 278,
    "response": "def check_tuples(tup, lst):\n    return len(tup) == len(lst)"
  },
  {
    "id": 279,
    "response": "def text_match(s):\n    pattern = re.compile(r'^a.+b$')\n    return bool(pattern.match(s))"
  },
  {
    "id": 280,
    "response": "def Check_Solution(n, n2, n3):\n    a = n\n    b = n2\n    c = n3\n    discriminant = b**2 - 4*a*c\n    if discriminant > 0:\n        return 2\n    elif discriminant == 0:\n        return 1\n    else:\n        return 0"
  },
  {
    "id": 281,
    "response": "def sum_even_odd(lst):\n    first_even = None\n    first_odd = None\n    for num in lst:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        if first_odd is None and num % 2 != 0:\n            first_odd = num\n    return first_even + first_odd if first_even is not None and first_odd is not None else 0"
  },
  {
    "id": 282,
    "response": "def parallelogram_perimeter(n, n2):\n    return 2 * (n + n2)"
  },
  {
    "id": 283,
    "response": "def div_of_nums(lst, m, n):\n    return list(filter(lambda x: x % m == 0 and x % n == 0, lst))"
  },
  {
    "id": 284,
    "response": "def all_Bits_Set_In_The_Given_Range(n, n2, n3):\n    if n2 > n3:\n        return False\n    mask = ((1 << (n3 + 1)) - 1) ^ ((1 << n2) - 1)\n    return (n & mask) == mask"
  },
  {
    "id": 285,
    "response": "def is_Isomorphic(s, s2):"
  },
  {
    "id": 286,
    "response": "def sum_num(lst):\n    return sum(lst) / len(lst)"
  },
  {
    "id": 287,
    "response": "def is_odd(n):\n    return (n & 1) == 1"
  },
  {
    "id": 288,
    "response": "def substract_elements(tup, tup2):\n    result = []\n    for a, b in zip(tup, tup2):\n        if isinstance(a, tuple) and isinstance(b, tuple):\n            result.append(substract_elements(a, b))\n        else:\n            result.append(a - b)\n    return tuple(result)"
  },
  {
    "id": 289,
    "response": "def reverse_list_lists(lst):\n    reversed_lists = []\n    for sublist in lst:\n        reversed_sublist = sublist[::-1]\n        reversed_lists.append(reversed_sublist)\n    return reversed_lists"
  },
  {
    "id": 290,
    "response": ""
  },
  {
    "id": 291,
    "response": "def same_Length(n, n2):\n    return len(str(abs(n))) == len(str(abs(n2)))"
  },
  {
    "id": 292,
    "response": "def remove_spaces(s):\n    return ' '.join(s.split())"
  },
  {
    "id": 293,
    "response": "def Extract(lst):\n    return lst[-1]"
  },
  {
    "id": 294,
    "response": "def float_to_tuple(s):\n    # Convert the string to a float\n    float_value = float(s)\n    # Convert the float to a tuple with a single element\n    return (float_value,)"
  },
  {
    "id": 295,
    "response": "def max_sum_subseq(lst):\n    if not lst:\n        return 0\n    if len(lst) == 1:\n        return lst[0]\n    # Initialize dp array\n    dp = [0] * len(lst)\n    dp[0] = lst[0]\n    dp[1] = max(lst[0], lst[1])\n    for i in range(2, len(lst)):\n        dp[i] = max(dp[i-1], dp[i-2] + lst[i])\n    return dp[-1]"
  },
  {
    "id": 296,
    "response": "def sort_list_last(lst):\n    return sorted(lst)"
  },
  {
    "id": 297,
    "response": "def is_Word_Present(s, s2):\n    # Check if s2 is present as a standalone word in s\n    if not s or not s2:\n        return False\n    # Use regex with word boundaries to match the exact word\n    pattern = r'\\b' + re.escape(s2) + r'\\b'\n    return bool(re.search(pattern, s))"
  },
  {
    "id": 298,
    "response": "def extract_elements(lst, n):\n    result = []\n    if len(lst) < n:\n        return result\n    for i in range(len(lst) - n + 1):\n        result.append(lst[i:i+n])\n    return result"
  },
  {
    "id": 299,
    "response": "def check(lst, n):\n    if not lst:\n        return False\n    return lst[0] + lst[-1] == n"
  },
  {
    "id": 300,
    "response": "def match_num(s):\n    if not s:\n        return 0\n    num_str = ''\n    for char in s:\n        if char.isdigit():\n            num_str += char\n        else:\n            break\n    if num_str:\n        return int(num_str)\n    else:\n        return 0"
  },
  {
    "id": 301,
    "response": "def num_comm_div(n, n2):\n    # Ensure the numbers are positive\n    n = abs(n)\n    n2 = abs(n2)\n    \n    # Euclidean algorithm to find GCD\n    while n2:\n        n, n2 = n2, n % n2\n    \n    return n"
  },
  {
    "id": 302,
    "response": "def find(n, n2):\n    return n % n2"
  },
  {
    "id": 303,
    "response": "def add_consecutive_nums(lst):\n    if not lst:\n        return 0\n    total_sum = 0\n    current_sequence = [lst[0]]\n    for num in lst[1:]:\n        if num == current_sequence[-1] + 1:\n            current_sequence.append(num)\n        else:\n            total_sum += sum(current_sequence)\n            current_sequence = [num]\n    # Add the last sequence\n    total_sum += sum(current_sequence)\n    return total_sum"
  },
  {
    "id": 304,
    "response": "def sum_Of_Series(n):\n    if n < 0:\n        return 0\n    return (n * (n + 1) // 2) ** 2"
  },
  {
    "id": 305,
    "response": "def re_order(lst):\n    non_zeros = [x for x in lst if x != 0]\n    zeros = [0] * (len(lst) - len(non_zeros))\n    return non_zeros + zeros"
  },
  {
    "id": 306,
    "response": "def permutation_coefficient(n, k):\n    if k > n:\n        return 0\n    if k == 0:\n        return 1\n    result = 1\n    for i in range(k):\n        result *= (n - i)\n    return result"
  },
  {
    "id": 307,
    "response": "def remove_words(lst, lst2):\n    to_remove = set(lst2)\n    return [word for word in lst if word not in to_remove]"
  },
  {
    "id": 308,
    "response": "def same_order(lst, lst2):\n    common1 = [x for x in lst if x in lst2]\n    common2 = [x for x in lst2 if x in lst]\n    return common1 == common2"
  },
  {
    "id": 309,
    "response": "def average_Odd(n):\n    if n < 1:\n        return 0\n    count = (n + 1) // 2\n    return count"
  },
  {
    "id": 310,
    "response": ""
  },
  {
    "id": 311,
    "response": "def find_Min_Sum(n):\n    if n == 1:\n        return 1\n    min_sum = n  # the case where the number itself is the only factor\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            # check if i and n//i are factors\n            current_sum = i + find_Min_Sum(n//i)\n            if current_sum < min_sum:\n                min_sum = current_sum\n    return min_sum"
  },
  {
    "id": 312,
    "response": "def flatten(tup):\n    result = []\n    for element in tup:\n        if isinstance(element, tuple):\n            result.extend(flatten(element))\n        else:\n            result.append(element)\n    return result"
  },
  {
    "id": 313,
    "response": "def add_str(tup, s):\n    return [str(element) + s for element in tup]"
  },
  {
    "id": 314,
    "response": "def sum_elements(tup):\n    return sum(tup)"
  },
  {
    "id": 315,
    "response": "def can_divide(lst, m):\n    possible_sums = {0}\n    for num in lst:\n        new_sums = set()\n        for r in possible_sums:\n            new_r = (r + num) % m\n            new_sums.add(new_r)\n        possible_sums.update(new_sums)\n        if 0 in possible_sums:\n            return True\n    return False"
  },
  {
    "id": 316,
    "response": "def radix_sort(lst):\n    if not lst:\n        return lst\n    \n    # Find the maximum number to determine the number of digits\n    max_num = max(lst)\n    max_digits = len(str(max_num))\n    \n    # Perform counting sort for each digit\n    for digit in range(max_digits):\n        # Create buckets for each digit (0-9)\n        buckets = [[] for _ in range(10)]\n        \n        # Distribute elements into buckets based on the current digit\n        for num in lst:\n            # Extract the current digit\n            current_digit = (num // (10 ** digit)) % 10\n            buckets[current_digit].append(num)\n        \n        # Collect elements from buckets back into the list\n        lst = []\n        for bucket in buckets:\n            lst.extend(bucket)\n    \n    return lst"
  },
  {
    "id": 317,
    "response": "def largest_pos(lst):\n    max_pos = None\n    for num in lst:\n        if num > 0:\n            if max_pos is None or num > max_pos:\n                max_pos = num\n    return max_pos"
  },
  {
    "id": 318,
    "response": "def sqrt_root(n):\n    if n < 0:\n        raise ValueError(\"Negative number does not have a real square root.\")\n    return math.sqrt(n)"
  },
  {
    "id": 319,
    "response": "def volume_tetrahedron(n):\n    if n <= 0:\n        return 0\n    return (n ** 3) / (6 * math.sqrt(2))"
  },
  {
    "id": 320,
    "response": "def get_lcm(lst):\n    if not lst:\n        return 0  # Or raise an error, but the problem might expect 0 for empty list\n    lcm = lst[0]\n    for num in lst[1:]:\n        gcd = math.gcd(lcm, num)\n        lcm = (lcm * num) // gcd\n    return lcm"
  },
  {
    "id": 321,
    "response": "def check_isosceles(n, n2, n3):\n    sides = sorted([n, n2, n3])\n    a, b, c = sides\n    if a + b <= c:\n        return False\n    if a == b or b == c:\n        return True\n    return False"
  },
  {
    "id": 322,
    "response": "def lbs(lst):\n    n = len(lst)\n    if n == 0:\n        return 0\n    \n    # Initialize the increasing and decreasing arrays\n    inc = [1] * n\n    dec = [1] * n\n    \n    # Compute the increasing subsequence lengths\n    for i in range(1, n):\n        for j in range(i):\n            if lst[j] < lst[i]:\n                inc[i] = max(inc[i], inc[j] + 1)\n    \n    # Compute the decreasing subsequence lengths\n    for i in range(n-2, -1, -1):\n        for j in range(i+1, n):\n            if lst[j] < lst[i]:\n                dec[i] = max(dec[i], dec[j] + 1)\n    \n    # Find the maximum bitonic subsequence length\n    max_len = 0\n    for i in range(n):\n        max_len = max(max_len, inc[i] + dec[i] - 1)\n    \n    return max_len"
  },
  {
    "id": 323,
    "response": "def check_string(s):\n    return any(c.isupper() for c in s) and any(c.islower() for c in s) and any(c.isdigit() for c in s) and len(s) >= 1"
  },
  {
    "id": 324,
    "response": "def max_sum_increasing_subsequence(lst, n):\n    if n == 0:\n        return 0\n    dp = [0] * n\n    for i in range(n):\n        dp[i] = lst[i]\n    for i in range(1, n):\n        for j in range(i):\n            if lst[j] < lst[i]:\n                dp[i] = max(dp[i], dp[j] + lst[i])\n    return max(dp)"
  },
  {
    "id": 325,
    "response": "def parallel_lines(lst1, lst2):\n    # Check if both lists have at least two points\n    if len(lst1) < 2 or len(lst2) < 2:\n        return True  # Assuming single points are considered parallel\n    # Get the first two points for each list\n    x1, y1 = lst1[0]\n    x2, y2 = lst1[1]\n    dx1 = x2 - x1\n    dy1 = y2 - y1"
  },
  {
    "id": 326,
    "response": "def capitalize_first_last_letters(s):\n    words = s.split()\n    result = []\n    for word in words:\n        if len(word) == 0:\n            continue  # skip empty words, though split() shouldn't return them\n        if len(word) == 1:\n            result.append(word.upper())\n        else:\n            first = word[0].upper()\n            last = word[-1].upper()\n            middle = word[1:-1]\n            result.append(first + middle + last)\n    return ' '.join(result)"
  },
  {
    "id": 327,
    "response": "def get_pairs_count(lst, n, n2):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if lst[i] + lst[j] == n or lst[i] + lst[j] == n2:\n                count +=1\n    return count"
  },
  {
    "id": 328,
    "response": "def min_length(lst):\n    return min(len(element) for element in lst)"
  },
  {
    "id": 329,
    "response": "def jacobsthal_lucas(n):\n    if n == 0:\n        return 2\n    elif n == 1:\n        return 1\n    a, b = 2, 1\n    for i in range(2, n+1):\n        c = b + 2*a\n        a, b = b, c\n    return b"
  },
  {
    "id": 330,
    "response": "def negative_count(lst):\n    if not lst:\n        return 0.0\n    negative_count = sum(1 for num in lst if num < 0)\n    return negative_count / len(lst)"
  },
  {
    "id": 331,
    "response": "def min_coins(lst, n, n2):\n    # process each element in lst\n    result = []\n    for v in lst:\n        # compute min coins for v\n        result.append(min_coins_for_value(v, n, n2))\n    return result"
  },
  {
    "id": 332,
    "response": "def check_permutation(s, s2):\n    if len(s) != len(s2):\n        return False\n    return sorted(s) == sorted(s2)"
  },
  {
    "id": 333,
    "response": "def remove_datatype(tup, param):\n    return tuple(element for element in tup if type(element) != param)"
  },
  {
    "id": 334,
    "response": "def search_literal(s, s2):\n    if not s2:\n        return 0\n    if len(s2) > len(s):\n        return -1\n    for i in range(len(s) - len(s2) + 1):\n        if s[i:i+len(s2)] == s2:\n            return i\n    return -1"
  },
  {
    "id": 335,
    "response": "def topbottom_surfacearea(n):\n    return math.pi * n ** 2"
  },
  {
    "id": 336,
    "response": "def nth_items(lst, n):\n    return lst[n-1]"
  },
  {
    "id": 337,
    "response": "def first_repeated_word(s):\n    words = s.split()\n    seen = set()\n    for word in words:\n        if word in seen:\n            return word\n        seen.add(word)\n    return None"
  },
  {
    "id": 338,
    "response": "def string_list_to_tuple(input_list):\n    return tuple(input_list)"
  },
  {
    "id": 339,
    "response": "def basesnum_coresspondingnum(lst, lst2):\n    return list(map(lambda x, y: x ** y, zip(lst, lst2)))"
  },
  {
    "id": 340,
    "response": "def find_Diff(lst, n):\n    counts = Counter(lst)\n    max_freq = max(counts.values())\n    min_freq = min(counts.values())\n    return max_freq - min_freq"
  },
  {
    "id": 341,
    "response": "def check_abundant(n):\n    if n <= 1:\n        return False\n    sum_div = 0\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            sum_div += i\n            counterpart = n // i\n            if counterpart != i and counterpart != n:\n                sum_div += counterpart\n    return sum_div > n"
  },
  {
    "id": 342,
    "response": "def fill_spaces(s):\n    return re.sub(r'[ .,]', '|', s)"
  },
  {
    "id": 343,
    "response": "def count_digits(n, n2):\n    result = n + n2\n    print(result)"
  },
  {
    "id": 344,
    "response": "def flatten_tuple(lst):\n    result = []\n    for element in lst:\n        if isinstance(element, tuple):\n            result.extend(flatten_tuple(element))\n        else:\n            result.append(element)\n    return result"
  },
  {
    "id": 345,
    "response": "def toggle_F_and_L_bits(n):\n    if n == 0:\n        return 0  # or handle as needed\n    msb_pos = n.bit_length() - 1\n    lsb_pos = (n & -n).bit_length() - 1\n    mask = (1 << msb_pos) | (1 << lsb_pos)\n    return n ^ mask"
  },
  {
    "id": 346,
    "response": "def last_occurence_char(s, s2):\n    return s.rfind(s2)"
  },
  {
    "id": 347,
    "response": "def Total_Hamming_Distance(n):\n    total = 0\n    for i in range(n):\n        total += bin(i ^ (i+1)).count('1')\n    return total"
  },
  {
    "id": 348,
    "response": "def longest_increasing_subsequence(lst):\n    if not lst:\n        return 0\n    tails = []\n    for num in lst:\n        # Find the first index in tails where the value is >= num\n        left, right = 0, len(tails)\n        while left < right:\n            mid = (left + right) // 2\n            if tails[mid] < num:\n                left = mid + 1\n            else:\n                right = mid\n        if left == len(tails):\n            tails.append(num)\n        else:\n            tails[left] = num\n    return len(tails)"
  },
  {
    "id": 349,
    "response": "def odd_Num_Sum(n):\n    total = 0\n    for i in range(1, n+1):\n        odd_num = 2*i -1\n        total += odd_num **5\n    return total"
  },
  {
    "id": 350,
    "response": ""
  },
  {
    "id": 351,
    "response": "def extract_column(lst, n):\n    return [row[n] for row in lst]"
  },
  {
    "id": 352,
    "response": "def Seq_Linear(lst):\n    if len(lst) <= 2:\n        return True\n    diff = lst[1] - lst[0]\n    for i in range(2, len(lst)):\n        if lst[i] - lst[i-1] != diff:\n            return False\n    return True"
  },
  {
    "id": 353,
    "response": "def tuple_to_float(tup):\n    # Convert each element of the tuple to a string, join them, and convert to float\n    return float(''.join(str(x) for x in tup))"
  },
  {
    "id": 354,
    "response": "def find_odd(lst):\n    for num in lst:\n        if num % 2 != 0:\n            return num\n    return None  # or raise an error if no odd found"
  },
  {
    "id": 355,
    "response": "def difference(n):\n    sum_n = n * (n + 1) // 2\n    return (sum_n ** 2) - sum_n"
  },
  {
    "id": 356,
    "response": "def find_Odd_Pair(lst, n):\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if (lst[i] ^ lst[j]) % 2 == 1:\n                return (i, j)\n    return None"
  },
  {
    "id": 357,
    "response": "def toggle_string(s):\n    return ''.join([char.lower() if char.isupper() else char.upper() if char.islower() else char for char in s])"
  },
  {
    "id": 358,
    "response": "def digit_distance_nums(n, n2):\n    # Convert numbers to strings\n    str_n = str(n)\n    str_n2 = str(n2)\n    \n    # Determine the maximum length\n    max_len = max(len(str_n), len(str_n2))\n    \n    # Pad with leading zeros to match the max length\n    str_n = str_n.zfill(max_len)\n    str_n2 = str_n2.zfill(max_len)\n    \n    # Calculate the digit distance\n    distance = 0\n    for d1, d2 in zip(str_n, str_n2):\n        distance += abs(int(d1) - int(d2))\n    \n    return distance"
  },
  {
    "id": 359,
    "response": "def max_sub_array_sum(lst, n):\n    if not lst or n <= 0 or n > len(lst):\n        return 0\n    current_sum = sum(lst[:n])\n    max_sum = current_sum\n    for i in range(n, len(lst)):\n        current_sum += lst[i] - lst[i - n]\n        if current_sum > max_sum:\n            max_sum = current_sum\n    return max_sum"
  },
  {
    "id": 360,
    "response": "def union_elements(tup, tup2):\n    # Convert both tuples to sets and take the union\n    set1 = set(tup)\n    set2 = set(tup2)\n    union_set = set1.union(set2)\n    # Convert the union set back to a tuple and return\n    return tuple(union_set)"
  },
  {
    "id": 361,
    "response": ""
  },
  {
    "id": 362,
    "response": "def Find_Max_Length(lst):\n    if not lst:\n        return 0\n    max_len = 0\n    for sublist in lst:\n        current_len = len(sublist)\n        if current_len > max_len:\n            max_len = current_len\n    return max_len"
  },
  {
    "id": 363,
    "response": "def extract_values(s):\n    values = []\n    current_value = ''\n    in_quotes = False\n    for char in s:\n        if char in ['\"', \"'\"]:\n            if not in_quotes:\n                in_quotes = True\n            else:\n                in_quotes = False\n                values.append(current_value)\n                current_value = ''\n        elif in_quotes:\n            current_value += char\n    return values"
  },
  {
    "id": 364,
    "response": ""
  },
  {
    "id": 365,
    "response": "def split(s):\n    return list(s)"
  },
  {
    "id": 366,
    "response": "def sum_digits(n):\n    total = 0\n    while n > 0:\n        total += n % 10\n        n = n // 10\n    return total"
  },
  {
    "id": 367,
    "response": "def issort_list(lst):\n    if len(lst) <= 1:\n        return True\n    for i in range(len(lst) - 1):\n        if lst[i] > lst[i+1]:\n            return False\n    return True"
  },
  {
    "id": 368,
    "response": "def empty_list(n):\n    return [{} for _ in range(n)]"
  },
  {
    "id": 369,
    "response": "def sort_sublists(lst):\n    return [sorted(sublist) for sublist in lst]"
  },
  {
    "id": 370,
    "response": "def remove_words(lst, lst2):\n    # Convert lst2 to a set for faster lookups\n    to_remove = set(lst2)\n    # Create a new list with elements from lst not in to_remove\n    return [word for word in lst if word not in to_remove]"
  },
  {
    "id": 371,
    "response": "def max_sum_pair_diff_lessthan_K(lst, k). But the example shows the parameters as lst, n, n2. Maybe the user made a mistake in the example. Alternatively, maybe the parameters are the list, and two integers n and n2, but that's unclear."
  },
  {
    "id": 372,
    "response": "def two_unique_nums(lst):\n    counts = {}\n    for num in lst:\n        counts[num] = counts.get(num, 0) + 1\n    duplicates = [num for num, count in counts.items() if count == 2]\n    return duplicates"
  },
  {
    "id": 373,
    "response": "def unique_product(lst):\n    unique_nums = set(lst)\n    if not unique_nums:\n        return 1\n    product = 1\n    for num in unique_nums:\n        product *= num\n    return product"
  },
  {
    "id": 374,
    "response": "def surfacearea_cylinder(n, n2):\n    return 2 * math.pi * n * (n + n2)"
  },
  {
    "id": 375,
    "response": "def count_no(n, n2, n3, n4):\n    count = 0\n    x = 1\n    while True:\n        if x % n2 != 0 and x % n3 != 0 and x % n4 != 0:\n            count +=1\n            if count == n:\n                return x\n        x +=1"
  },
  {
    "id": 376,
    "response": "def is_Sub_Array(lst, lst2, n, n2):\n    # Check for edge cases\n    if n2 == 0:\n        return True\n    if n == 0 or n2 > n:\n        return False\n    \n    # Check if lst2 is a subarray of lst\n    for i in range(n - n2 + 1):\n        if lst[i:i+n2] == lst2:\n            return True\n    return False"
  },
  {
    "id": 377,
    "response": "def last_Digit_Factorial(n):\n    if n == 0:\n        return 1\n    elif n == 1:\n        return 1\n    elif n == 2:\n        return 2\n    elif n == 3:\n        return 6\n    elif n == 4:\n        return 4\n    else:\n        return 0"
  },
  {
    "id": 378,
    "response": "def interleave_lists(lst, lst2, lst3):\n    if len(lst) != len(lst2) or len(lst) != len(lst3):\n        raise ValueError(\"All lists must be of the same length\")\n    result = []\n    for i in range(len(lst)):\n        result.append(lst[i])\n        result.append(lst2[i])\n        result.append(lst3[i])\n    return result"
  },
  {
    "id": 379,
    "response": "def find_dissimilar(tup, tup2):\n    set1 = set(tup)\n    set2 = set(tup2)\n    return tuple(set1.symmetric_difference(set2))"
  },
  {
    "id": 380,
    "response": "def extract_even(tup):\n    result = []\n    for element in tup:\n        if isinstance(element, tuple):\n            result.extend(extract_even(element))\n        else:\n            if element % 2 == 0:\n                result.append(element)\n    return result"
  },
  {
    "id": 381,
    "response": "def surface_Area(n, n2):\n    base_area = n ** 2\n    lateral_area = 2 * n * n2\n    return base_area + lateral_area"
  },
  {
    "id": 382,
    "response": "def is_empty_dict(dct):\n    return len(dct) == 0"
  },
  {
    "id": 383,
    "response": "def catalan_number(n):\n    if n < 0:\n        return 0\n    catalan = 1\n    for i in range(1, n + 1):\n        catalan = catalan * (2 * (2 * i - 1)) // (i + 1)\n    return catalan"
  },
  {
    "id": 384,
    "response": "def find_adverbs(s):\n    pattern = r'\\b\\w+ly\\b'\n    matches = re.finditer(pattern, s)\n    result = []\n    for match in matches:\n        word = match.group()\n        start = match.start()\n        result.append((word, start))\n    return result"
  },
  {
    "id": 385,
    "response": "def expensive_items(lst, n):\n    return [item for item in lst if item.get('price', 0) > n]"
  },
  {
    "id": 386,
    "response": ""
  },
  {
    "id": 387,
    "response": "def list_tuple(lst):\n    return tuple(lst)"
  },
  {
    "id": 388,
    "response": "def big_diff(lst):\n    return max(lst) - min(lst)"
  },
  {
    "id": 389,
    "response": "def perfect_squares(n, n2):\n    # Determine the start and end of the range\n    start = min(n, n2)\n    end = max(n, n2)\n    perfect_squares_list = []\n    # Iterate through each number in the range\n    for num in range(start, end + 1):\n        # Check if the number is a perfect square\n        root = int(num ** 0.5)\n        if root * root == num:\n            perfect_squares_list.append(num)\n    return perfect_squares_list"
  },
  {
    "id": 390,
    "response": "def polar_rect(n, n2):\n    x = n * math.cos(n2)\n    y = n * math.sin(n2)\n    return (x, y)"
  },
  {
    "id": 391,
    "response": "def swap_List(lst):\n    if len(lst) < 2:\n        return lst\n    lst[0], lst[-1] = lst[-1], lst[0]\n    return lst"
  },
  {
    "id": 392,
    "response": "def sum_Of_product(n):\n    product = 1\n    for k in range(n + 1):\n        product *= math.comb(n, k)\n    return product"
  },
  {
    "id": 393,
    "response": "def removezero_ip(s):\n    parts = s.split('.')\n    result = []\n    for part in parts:\n        stripped = part.lstrip('0')\n        if stripped == '':\n            result.append('0')\n        else:\n            result.append(stripped)\n    return '.'.join(result)"
  },
  {
    "id": 394,
    "response": "def diff_even_odd(lst):\n    first_even = None\n    first_odd = None\n    for num in lst:\n        if num % 2 == 0:\n            if first_even is None:\n                first_even = num\n        else:\n            if first_odd is None:\n                first_odd = num\n    return first_even - first_odd"
  },
  {
    "id": 395,
    "response": "def min_swaps(s, s2):\n    count = 0\n    for a, b in zip(s, s2):\n        if a != b:\n            count += 1\n    return count // 2"
  },
  {
    "id": 396,
    "response": "def tuple_size(tup):\n    return len(tup)"
  },
  {
    "id": 397,
    "response": "def find_kth(lst, lst2, n, n2, k):"
  },
  {
    "id": 398,
    "response": "def armstrong_number(n):\n    if n < 0:\n        return False\n    digits = list(str(n))\n    power = len(digits)\n    sum_of_powers = sum(int(digit) ** power for digit in digits)\n    return sum_of_powers == n"
  },
  {
    "id": 399,
    "response": "def sum_average(n):\n    if n <= 0:\n        return 0, 0\n    total = n * (n + 1) // 2\n    average = total / n\n    return total, average"
  },
  {
    "id": 400,
    "response": "def is_Even(n):\n    return (n & 1) == 0"
  }
]